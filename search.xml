<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>牛客面试题-Java工程师</title>
      <link href="posts/86sjk55a.html"/>
      <url>posts/86sjk55a.html</url>
      
        <content type="html"><![CDATA[<p>每日一练：</p><p>1.定义类中成员变量时不可能用到的修饰是<strong>（B）</strong></p><p><code>A.final</code></p><p><code>B.void</code></p><p><code>C.protected</code></p><p><code>D.static</code></p><p>解析：void修饰的是成员方法，不能修饰成员变量，没有返回值，final是修饰常量的，protected是保护的，static是静态的</p><p>2.已知表达式int m[]={0，1，2，3，4，5，6}；下面哪个表达式的值与数组下标量最大值相等？<strong>（B）</strong></p><pre><code class="java">A  m. length()B  m. length-1C  m. length()+1D  m. length+1</code></pre><p>解析：B      </p><p>m的下标是从0开始的</p><p>length — arrays (int[], double[], String[]) —- to know the length of the arrays</p><p>length() — String related Object (String, StringBuilder etc)to know the length of the String </p><p>size() — Collection Object (ArrayList, Set etc)to know the size of the Collection</p><p>3.判断对错。List，Set，Map都继承自继承Collection接口。**(B)**</p><p><code>A.对</code></p><p><code>B.错</code></p><p>解析：B</p><p>List，Set等集合对象都继承自Collection接口</p><p>Map是一个顶层结果，不继承自Collection接口</p><p>Collection接口：</p><p>1、List接口：内容允许重复</p><p>1.1、ArrayList</p><p>1.2、LinkedList，也实现了Queue接口</p><p>1.3、Vector</p><p>2、Set接口：内容不允许重复</p><p>3、Queue接口：队列接口</p><p>4、sortedSet接口：单值排序接口</p><p>Map接口：</p><p>1、HashMap：无序存放，key不重复</p><p>2、HashTable接口：无序存放，key不重复</p><p>3、TreeMap接口：按key排序，key不重复</p><p>4、IdentityHashMap接口:key可重复</p><p>5、WeakHashMap接口：弱引Map集合</p><p>4.下列程序执行后输出结果为<strong>（D）</strong></p><pre><code class="java">class BaseClass &#123; public BaseClass() &#123;&#125; &#123; System.out.println(&quot;I’m BaseClass class&quot;); &#125; static &#123; System.out.println(&quot;static BaseClass&quot;); &#125; &#125; public class Base extends BaseClass &#123; public Base() &#123;&#125; &#123; System.out.println(&quot;I’m Base class&quot;); &#125; static &#123; System.out.println(&quot;static Base&quot;); &#125; public static void main(String[] args) &#123; new Base(); &#125; &#125;</code></pre><pre><code class="java">Astatic BaseClassI’m BaseClass classstatic BaseI’m Base classBI’m BaseClass classI’m Base classstatic BaseClassstatic BaseCI’m BaseClass classstatic BaseClassI’m Base classstatic BaseDstatic BaseClassstatic BaseI’m BaseClass classI’m Base class</code></pre><p>解析：D</p><p>补充一下完整版的，执行顺序从左到右：</p><p>父类静态代码块 -&gt;子类静态代码块 -&gt;父类非静态代码块 -&gt; 父类构造函数 -&gt; 子类非静态代码块 -&gt; 子类构造函数。</p><pre><code class="java">public class Father &#123;  static &#123;        System.out.println(&quot;父类静态代码块&quot;);    &#125;    &#123;        System.out.println(&quot;父类非静态代码块&quot;);    &#125;  public Father()&#123;        System.out.println(&quot;父类构造函数&quot;);    &#125;   &#125;public class Son extends Father&#123;  static &#123;        System.out.println(&quot;子类静态代码块&quot;);    &#125;    &#123;        System.out.println(&quot;子类非静态代码块&quot;);    &#125;  public Son()&#123;        System.out.println(&quot;子类构造函数&quot;);    &#125;  public static void main(String[] args) &#123;        Son son = new Son();    &#125;&#125;结果为：   父类静态代码块    子类静态代码块    父类非静态代码块    父类构造函数    子类非静态代码块    子类构造函数 </code></pre><p>5.如果一个接口Glass有个方法setColor()，有个类BlueGlass实现接口Glass，则在类BlueGlass中正确的是？  <strong>( C)</strong></p><pre><code class="java">A   protected void setColor() &#123; …&#125;B   void setColor() &#123; …&#125;C   public void setColor() &#123; …&#125;D   以上语句都可以用在类BlueGlass中</code></pre><p>解析：C</p><pre><code class="java">JAVA 子类重写继承的方法时,不可以降低方法的访问权限，子类继承父类的访问修饰符要比父类的更大，也就是更加开放，假如我父类是protected修饰的，其子类只能是protected或者public，绝对不能是friendly(默认的访问范围)或者private，当然使用private就不是继承了。还要注意的是，继承当中子类抛出的异常必须是父类抛出的异常的子异常，或者子类抛出的异常要比父类抛出的异常要少。接口中属性为public static final。方法为public abstract。子类的权限不能比父类更低</code></pre>]]></content>
      
      
      <categories>
          
          <category> 牛客-java面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛客 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode算法-数组和字符串</title>
      <link href="posts/78ds5we6.html"/>
      <url>posts/78ds5we6.html</url>
      
        <content type="html"><![CDATA[<h3 id="LC寻找数组的中心索引"><a href="#LC寻找数组的中心索引" class="headerlink" title="LC寻找数组的中心索引"></a>LC寻找数组的中心索引</h3><p>给你一个整数数组 nums，请编写一个能够返回数组 “中心索引” 的方法。</p><p>数组 中心索引 是数组的一个索引，其左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果数组不存在中心索引，返回 -1 。如果数组有多个中心索引，应该返回最靠近左边的那一个。</p><p>注意：中心索引可能出现在数组的两端。</p><p>示例 1：</p><p><code>输入：nums = [1, 7, 3, 6, 5, 6] 输出：3 解释： 中心索引是 3 。 左侧数之和 (1 + 7 + 3 = 11)， 右侧数之和 (5 + 6 = 11) ，二者相等。</code></p><p>示例 2：</p><p><code>输入：nums = [1, 2, 3]</code><br><code>输出：-1</code><br><code>解释：</code><br><code>数组中不存在满足此条件的中心索引。</code><br>示例 3：</p><p><code>输入：nums = [2, 1, -1]</code><br><code>输出：0</code><br><code>解释：</code><br><code>中心索引是 0 。</code><br><code>索引 0 左侧不存在元素，视作和为 0 ；</code><br><code>右侧数之和为 1 + (-1) = 0 ，二者相等。</code></p><p>提示：</p><p><code>nums 的长度范围为 [0, 10000]。</code><br><code>任何一个 nums[i] 将会是一个范围在 [-1000, 1000]的整数。</code></p><p>解题思路：</p><p>当时的思路是这样的，算出来所有数的和，然后指针索引从左边向右边移动，看一下左边和是不是等于右边的和，如果相等就返回这个指针索引的位置，否则找不到就返回-1。</p><p>现在整理的时候又有了两个新思路。</p><p>思路1：</p><p>算出所有数的总和之后，直接从左边开始加什么时候等于总和的一半为止，如果没找到就返回-1；</p><p>思路2：</p><p>双指针索引方法，一个从左边开始加，一个从右边开始加，如果左边和大于右边和就右边指针索引向左移动一下，否则左边移动一下，直到两个指针相遇了，判断两边和相等不，如果相等就返回这个位置，如果不等就返回-1。但是有个细节要注意，就是有多个中心索引的情况，因此不能两边相等就停止，而应该是两指针相遇的时候才停止，并且右边的指针再相等的情况下应该优先动，这样才能保证是最左边的中心索引。</p><p>代码实现：</p><pre><code class="java">class Solution &#123;    public int pivotIndex(int[] nums) &#123;        if(nums.length &lt; 2)            return -1;        int leftSum = 0;        int rightSum = 0;        int sum = 0;        for(int n:nums)&#123;            sum += n;        &#125;        System.out.println(sum);        int i;        for(i=0;i&lt;nums.length;i++)&#123;            if(i==0)                leftSum = 0;            else                leftSum += nums[i-1];            rightSum = sum - leftSum - nums[i];            if(leftSum == rightSum)                return i;        &#125;        System.out.println(i);        return -1;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode算法-数组和字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数组和字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaReflection（Java反射）</title>
      <link href="posts/78ds5we6.html"/>
      <url>posts/78ds5we6.html</url>
      
        <content type="html"><![CDATA[<p>一、Java反射机制的研究与应用</p><p>二、反射的原理分析</p><p>三、JVM与类</p><p>四、类的加载、连接、初始化</p><p>五、类初始化的时机</p><p>六、类加载器ClassLoader简介</p><p>七、类加载机制</p><p>八、创建并使用自定义的类加载器</p><p>九、开启反射的源头Class</p><p>十、获取Class实例的四种方式</p><p>十一、从Class中获取信息</p><p>十二、Proxy和InvocationHandler创建动态代理</p><p>十三、动态代理和AOP（Aspect Orient Programming）</p><p>十四、泛型和Class类</p><p>十五、使用反射来获取泛型信息</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射机制与原理分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaIO流</title>
      <link href="posts/7wu77io3.html"/>
      <url>posts/7wu77io3.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、IO流结构体系"><a href="#一、IO流结构体系" class="headerlink" title="一、IO流结构体系"></a>一、IO流结构体系</h3><h3 id="二、IO流原理分析"><a href="#二、IO流原理分析" class="headerlink" title="二、IO流原理分析"></a>二、IO流原理分析</h3><h3 id="三、IO流的分类"><a href="#三、IO流的分类" class="headerlink" title="三、IO流的分类"></a>三、IO流的分类</h3><h3 id="四、IO流与文件操作"><a href="#四、IO流与文件操作" class="headerlink" title="四、IO流与文件操作"></a>四、IO流与文件操作</h3><h3 id="五、IO流的包装与链接"><a href="#五、IO流的包装与链接" class="headerlink" title="五、IO流的包装与链接"></a>五、IO流的包装与链接</h3><h3 id="六、缓冲流"><a href="#六、缓冲流" class="headerlink" title="六、缓冲流"></a>六、缓冲流</h3><h3 id="七、文件的复制和性能对比"><a href="#七、文件的复制和性能对比" class="headerlink" title="七、文件的复制和性能对比"></a>七、文件的复制和性能对比</h3><h3 id="八、对象流"><a href="#八、对象流" class="headerlink" title="八、对象流"></a>八、对象流</h3><h3 id="九、对象的序列化与反序列化"><a href="#九、对象的序列化与反序列化" class="headerlink" title="九、对象的序列化与反序列化"></a>九、对象的序列化与反序列化</h3><h3 id="十、控制台IO"><a href="#十、控制台IO" class="headerlink" title="十、控制台IO"></a>十、控制台IO</h3><h3 id="十一、标准输入流与标准输出流"><a href="#十一、标准输入流与标准输出流" class="headerlink" title="十一、标准输入流与标准输出流"></a>十一、标准输入流与标准输出流</h3><h3 id="十二、打印流"><a href="#十二、打印流" class="headerlink" title="十二、打印流"></a>十二、打印流</h3><h3 id="十三、转换流"><a href="#十三、转换流" class="headerlink" title="十三、转换流"></a>十三、转换流</h3><h3 id="十四、字符编码与解码"><a href="#十四、字符编码与解码" class="headerlink" title="十四、字符编码与解码"></a>十四、字符编码与解码</h3><h3 id="十五、RandomAccessFile类"><a href="#十五、RandomAccessFile类" class="headerlink" title="十五、RandomAccessFile类"></a>十五、RandomAccessFile类</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="posts/76fs5we6.html"/>
      <url>posts/76fs5we6.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、线程的原理"><a href="#一、线程的原理" class="headerlink" title="一、线程的原理"></a>一、线程的原理</h3><h3 id="二、线程的创建与启动"><a href="#二、线程的创建与启动" class="headerlink" title="二、线程的创建与启动"></a>二、线程的创建与启动</h3><h3 id="三、创建线程的几种方式对比"><a href="#三、创建线程的几种方式对比" class="headerlink" title="三、创建线程的几种方式对比"></a>三、创建线程的几种方式对比</h3><h3 id="四、继承Thread类与实现Runnable接口"><a href="#四、继承Thread类与实现Runnable接口" class="headerlink" title="四、继承Thread类与实现Runnable接口"></a>四、继承Thread类与实现Runnable接口</h3><h3 id="五、创建线程方式对比"><a href="#五、创建线程方式对比" class="headerlink" title="五、创建线程方式对比"></a>五、创建线程方式对比</h3><h3 id="六、线程的控制"><a href="#六、线程的控制" class="headerlink" title="六、线程的控制"></a>六、线程的控制</h3><h3 id="七、线程的调度"><a href="#七、线程的调度" class="headerlink" title="七、线程的调度"></a>七、线程的调度</h3><h3 id="八、线程的优先级"><a href="#八、线程的优先级" class="headerlink" title="八、线程的优先级"></a>八、线程的优先级</h3><h3 id="九、线程的生命周期"><a href="#九、线程的生命周期" class="headerlink" title="九、线程的生命周期"></a>九、线程的生命周期</h3><h3 id="十、多线程的安全问题与解决办法"><a href="#十、多线程的安全问题与解决办法" class="headerlink" title="十、多线程的安全问题与解决办法"></a>十、多线程的安全问题与解决办法</h3><h3 id="十一、线程的同步"><a href="#十一、线程的同步" class="headerlink" title="十一、线程的同步"></a>十一、线程的同步</h3><h3 id="十二、互斥锁"><a href="#十二、互斥锁" class="headerlink" title="十二、互斥锁"></a>十二、互斥锁</h3><h3 id="十三、线程的死锁问题"><a href="#十三、线程的死锁问题" class="headerlink" title="十三、线程的死锁问题"></a>十三、线程的死锁问题</h3><h3 id="十四、线程通信"><a href="#十四、线程通信" class="headerlink" title="十四、线程通信"></a>十四、线程通信</h3><h3 id="十五、生产者与消费者案例"><a href="#十五、生产者与消费者案例" class="headerlink" title="十五、生产者与消费者案例"></a>十五、生产者与消费者案例</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合与泛型</title>
      <link href="posts/34iuk7ab.html"/>
      <url>posts/34iuk7ab.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、集合框架概述"><a href="#一、集合框架概述" class="headerlink" title="一、集合框架概述"></a>一、集合框架概述</h3><h3 id="二、Collection系列集合"><a href="#二、Collection系列集合" class="headerlink" title="二、Collection系列集合"></a>二、Collection系列集合</h3><h3 id="三、List系列集合与Set系列集合"><a href="#三、List系列集合与Set系列集合" class="headerlink" title="三、List系列集合与Set系列集合"></a>三、List系列集合与Set系列集合</h3><h3 id="四、java-util-ArrayList源码与数据结构分析"><a href="#四、java-util-ArrayList源码与数据结构分析" class="headerlink" title="四、java.util.ArrayList源码与数据结构分析"></a>四、java.util.ArrayList源码与数据结构分析</h3><h3 id="五、java-util-LinkedList源码分析"><a href="#五、java-util-LinkedList源码分析" class="headerlink" title="五、java.util.LinkedList源码分析"></a>五、java.util.LinkedList源码分析</h3><h3 id="六、java-util-HashSet内部原理"><a href="#六、java-util-HashSet内部原理" class="headerlink" title="六、java.util.HashSet内部原理"></a>六、java.util.HashSet内部原理</h3><h3 id="七、java-util-TreeSet数据结构分析"><a href="#七、java-util-TreeSet数据结构分析" class="headerlink" title="七、java.util.TreeSet数据结构分析"></a>七、java.util.TreeSet数据结构分析</h3><h3 id="八、java7中Map系列集合与数据结构分析"><a href="#八、java7中Map系列集合与数据结构分析" class="headerlink" title="八、java7中Map系列集合与数据结构分析"></a>八、java7中Map系列集合与数据结构分析</h3><h3 id="九、java8中Map系列集合新特性对比"><a href="#九、java8中Map系列集合新特性对比" class="headerlink" title="九、java8中Map系列集合新特性对比"></a>九、java8中Map系列集合新特性对比</h3><h3 id="十、java-util-concurrent-ConcurrentHashMap"><a href="#十、java-util-concurrent-ConcurrentHashMap" class="headerlink" title="十、java.util.concurrent.ConcurrentHashMap"></a>十、java.util.concurrent.ConcurrentHashMap</h3><h3 id="十一、Iterator与Listlterator"><a href="#十一、Iterator与Listlterator" class="headerlink" title="十一、Iterator与Listlterator"></a>十一、Iterator与Listlterator</h3><h3 id="十二、Collections工具类"><a href="#十二、Collections工具类" class="headerlink" title="十二、Collections工具类"></a>十二、Collections工具类</h3><h3 id="十三、集合中使用的泛型"><a href="#十三、集合中使用的泛型" class="headerlink" title="十三、集合中使用的泛型"></a>十三、集合中使用的泛型</h3><h3 id="十四、自定义泛型"><a href="#十四、自定义泛型" class="headerlink" title="十四、自定义泛型"></a>十四、自定义泛型</h3><h3 id="十五、通配符"><a href="#十五、通配符" class="headerlink" title="十五、通配符"></a>十五、通配符</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java异常处理</title>
      <link href="posts/18d2b4e6.html"/>
      <url>posts/18d2b4e6.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、异常处理"><a href="#一、异常处理" class="headerlink" title="一、异常处理"></a>一、异常处理</h3><h3 id="二、异常的堆栈抛出机制"><a href="#二、异常的堆栈抛出机制" class="headerlink" title="二、异常的堆栈抛出机制"></a>二、异常的堆栈抛出机制</h3><h3 id="三、异常的结构体系"><a href="#三、异常的结构体系" class="headerlink" title="三、异常的结构体系"></a>三、异常的结构体系</h3><h3 id="四、受检与非检异常"><a href="#四、受检与非检异常" class="headerlink" title="四、受检与非检异常"></a>四、受检与非检异常</h3><h3 id="五、异常的处理"><a href="#五、异常的处理" class="headerlink" title="五、异常的处理"></a>五、异常的处理</h3><h3 id="六、try-catch示例"><a href="#六、try-catch示例" class="headerlink" title="六、try-catch示例"></a>六、try-catch示例</h3><h3 id="七、使用finally回收资源"><a href="#七、使用finally回收资源" class="headerlink" title="七、使用finally回收资源"></a>七、使用finally回收资源</h3><h3 id="八、throw制造异常"><a href="#八、throw制造异常" class="headerlink" title="八、throw制造异常"></a>八、throw制造异常</h3><h3 id="九、异常的处理方式之thows"><a href="#九、异常的处理方式之thows" class="headerlink" title="九、异常的处理方式之thows"></a>九、异常的处理方式之thows</h3><h3 id="十、Java7增强的throw语句"><a href="#十、Java7增强的throw语句" class="headerlink" title="十、Java7增强的throw语句"></a>十、Java7增强的throw语句</h3><h3 id="十一、方法重写与throws"><a href="#十一、方法重写与throws" class="headerlink" title="十一、方法重写与throws"></a>十一、方法重写与throws</h3><h3 id="十二、自定义异常"><a href="#十二、自定义异常" class="headerlink" title="十二、自定义异常"></a>十二、自定义异常</h3><h3 id="十三、实战中自定义异常的应用解析"><a href="#十三、实战中自定义异常的应用解析" class="headerlink" title="十三、实战中自定义异常的应用解析"></a>十三、实战中自定义异常的应用解析</h3><h3 id="十四、异常信息的访问"><a href="#十四、异常信息的访问" class="headerlink" title="十四、异常信息的访问"></a>十四、异常信息的访问</h3><h3 id="十五、Java程序的常见问题及解决方法"><a href="#十五、Java程序的常见问题及解决方法" class="headerlink" title="十五、Java程序的常见问题及解决方法"></a>十五、Java程序的常见问题及解决方法</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaAPI</title>
      <link href="posts/19d6a3e6.html"/>
      <url>posts/19d6a3e6.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、Warpper包装类"><a href="#一、Warpper包装类" class="headerlink" title="一、Warpper包装类"></a>一、Warpper包装类</h2><h3 id="二、装箱与拆箱"><a href="#二、装箱与拆箱" class="headerlink" title="二、装箱与拆箱"></a>二、装箱与拆箱</h3><h3 id="三、包装类的缓存分析"><a href="#三、包装类的缓存分析" class="headerlink" title="三、包装类的缓存分析"></a>三、包装类的缓存分析</h3><h3 id="四、字符串处理类"><a href="#四、字符串处理类" class="headerlink" title="四、字符串处理类"></a>四、字符串处理类</h3><h3 id="五、String类的使用与内存与原理"><a href="#五、String类的使用与内存与原理" class="headerlink" title="五、String类的使用与内存与原理"></a>五、String类的使用与内存与原理</h3><h3 id="六、String类的算法分析"><a href="#六、String类的算法分析" class="headerlink" title="六、String类的算法分析"></a>六、String类的算法分析</h3><h3 id="七、StringBuffer与StringBuilder"><a href="#七、StringBuffer与StringBuilder" class="headerlink" title="七、StringBuffer与StringBuilder"></a>七、StringBuffer与StringBuilder</h3><h3 id="八、字符串处理类性能分析"><a href="#八、字符串处理类性能分析" class="headerlink" title="八、字符串处理类性能分析"></a>八、字符串处理类性能分析</h3><h3 id="九、其他常用类"><a href="#九、其他常用类" class="headerlink" title="九、其他常用类"></a>九、其他常用类</h3><h3 id="十、Java-lang-System类"><a href="#十、Java-lang-System类" class="headerlink" title="十、Java.lang.System类"></a>十、Java.lang.System类</h3><h3 id="十一、Java-util-Date类"><a href="#十一、Java-util-Date类" class="headerlink" title="十一、Java.util.Date类"></a>十一、Java.util.Date类</h3><h3 id="十二、Java-text-SimpleDateFormat类"><a href="#十二、Java-text-SimpleDateFormat类" class="headerlink" title="十二、Java.text.SimpleDateFormat类"></a>十二、Java.text.SimpleDateFormat类</h3><h3 id="十三、Java-util-Calendar类"><a href="#十三、Java-util-Calendar类" class="headerlink" title="十三、Java.util.Calendar类"></a>十三、Java.util.Calendar类</h3><h3 id="十四、Java-lang-Math类"><a href="#十四、Java-lang-Math类" class="headerlink" title="十四、Java.lang.Math类"></a>十四、Java.lang.Math类</h3><h3 id="十五、Java-math-BingInteger类与Java-math-BigDecimal"><a href="#十五、Java-math-BingInteger类与Java-math-BigDecimal" class="headerlink" title="十五、Java.math.BingInteger类与Java.math.BigDecimal"></a>十五、Java.math.BingInteger类与Java.math.BigDecimal</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 包装、装箱、拆箱 </tag>
            
            <tag> String </tag>
            
            <tag> 核心类库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java高级类特性</title>
      <link href="posts/15d2a4e6.html"/>
      <url>posts/15d2a4e6.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、抽象类-（abstract）实际应用举例"><a href="#一、抽象类-（abstract）实际应用举例" class="headerlink" title="一、抽象类 （abstract）实际应用举例"></a>一、抽象类 （abstract）实际应用举例</h3><h3 id="二、接口（interface）的应用与常见问题"><a href="#二、接口（interface）的应用与常见问题" class="headerlink" title="二、接口（interface）的应用与常见问题"></a>二、接口（interface）的应用与常见问题</h3><h3 id="三、Java8-Java9-Java10对接口的改进"><a href="#三、Java8-Java9-Java10对接口的改进" class="headerlink" title="三、Java8/Java9/Java10对接口的改进"></a>三、Java8/Java9/Java10对接口的改进</h3><h3 id="四、Template-Method-设计模式"><a href="#四、Template-Method-设计模式" class="headerlink" title="四、Template Method 设计模式"></a>四、Template Method 设计模式</h3><h3 id="五、代理模式（Proxy）"><a href="#五、代理模式（Proxy）" class="headerlink" title="五、代理模式（Proxy）"></a>五、代理模式（Proxy）</h3><h3 id="六、类的成员之内部类"><a href="#六、类的成员之内部类" class="headerlink" title="六、类的成员之内部类"></a>六、类的成员之内部类</h3><h3 id="七、匿名内部类"><a href="#七、匿名内部类" class="headerlink" title="七、匿名内部类"></a>七、匿名内部类</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="八、Java8中匿名内部类的新特性"><a href="#八、Java8中匿名内部类的新特性" class="headerlink" title="八、Java8中匿名内部类的新特性"></a>八、Java8中匿名内部类的新特性</h3><h3 id="九、Enum枚举"><a href="#九、Enum枚举" class="headerlink" title="九、Enum枚举"></a>九、Enum枚举</h3><h3 id="十、枚举的属性与方法"><a href="#十、枚举的属性与方法" class="headerlink" title="十、枚举的属性与方法"></a>十、枚举的属性与方法</h3><h3 id="十一、接口实现枚举类"><a href="#十一、接口实现枚举类" class="headerlink" title="十一、接口实现枚举类"></a>十一、接口实现枚举类</h3><h3 id="十二、Annotation注解"><a href="#十二、Annotation注解" class="headerlink" title="十二、Annotation注解"></a>十二、Annotation注解</h3><h3 id="十三、JDK内置注解"><a href="#十三、JDK内置注解" class="headerlink" title="十三、JDK内置注解"></a>十三、JDK内置注解</h3><h3 id="十四、自定义注解"><a href="#十四、自定义注解" class="headerlink" title="十四、自定义注解"></a>十四、自定义注解</h3><h3 id="十五、元注解"><a href="#十五、元注解" class="headerlink" title="十五、元注解"></a>十五、元注解</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抽象类 </tag>
            
            <tag> 接口 </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 枚举 </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面对对象编程</title>
      <link href="posts/16s23sd4.html"/>
      <url>posts/16s23sd4.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、面向对象与面向过程的理解"><a href="#一、面向对象与面向过程的理解" class="headerlink" title="一、面向对象与面向过程的理解"></a>一、面向对象与面向过程的理解</h3><h3 id="二、类和对象的理解"><a href="#二、类和对象的理解" class="headerlink" title="二、类和对象的理解"></a>二、类和对象的理解</h3><h3 id="三、类和对象的创建、使用"><a href="#三、类和对象的创建、使用" class="headerlink" title="三、类和对象的创建、使用"></a>三、类和对象的创建、使用</h3><h3 id="四、属性"><a href="#四、属性" class="headerlink" title="四、属性"></a>四、属性</h3><h3 id="五、方法"><a href="#五、方法" class="headerlink" title="五、方法"></a>五、方法</h3><h3 id="六、包"><a href="#六、包" class="headerlink" title="六、包"></a>六、包</h3><h3 id="七、this"><a href="#七、this" class="headerlink" title="七、this"></a>七、this</h3><h3 id="八、构造器"><a href="#八、构造器" class="headerlink" title="八、构造器"></a>八、构造器</h3><h3 id="九、封装"><a href="#九、封装" class="headerlink" title="九、封装"></a>九、封装</h3><h3 id="十、JavaBran"><a href="#十、JavaBran" class="headerlink" title="十、JavaBran"></a>十、JavaBran</h3><h3 id="十一、继承"><a href="#十一、继承" class="headerlink" title="十一、继承"></a>十一、继承</h3><h3 id="十二、super关键字"><a href="#十二、super关键字" class="headerlink" title="十二、super关键字"></a>十二、super关键字</h3><h3 id="十三、重写"><a href="#十三、重写" class="headerlink" title="十三、重写"></a>十三、重写</h3><h3 id="十四、多态"><a href="#十四、多态" class="headerlink" title="十四、多态"></a>十四、多态</h3><h3 id="十五、Object类"><a href="#十五、Object类" class="headerlink" title="十五、Object类"></a>十五、Object类</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类和对象 </tag>
            
            <tag> 封装 </tag>
            
            <tag> 继承 </tag>
            
            <tag> 多态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数组</title>
      <link href="posts/45as5de6.html"/>
      <url>posts/45as5de6.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、static修饰符"><a href="#一、static修饰符" class="headerlink" title="一、static修饰符"></a>一、static修饰符</h3><h3 id="二、类的成员之代码块"><a href="#二、类的成员之代码块" class="headerlink" title="二、类的成员之代码块"></a>二、类的成员之代码块</h3><h3 id="三、静态代码与非静态代码块"><a href="#三、静态代码与非静态代码块" class="headerlink" title="三、静态代码与非静态代码块"></a>三、静态代码与非静态代码块</h3><h3 id="四、单例（Singleton）设计模式"><a href="#四、单例（Singleton）设计模式" class="headerlink" title="四、单例（Singleton）设计模式"></a>四、单例（Singleton）设计模式</h3><h3 id="五、final修饰符"><a href="#五、final修饰符" class="headerlink" title="五、final修饰符"></a>五、final修饰符</h3><h3 id="六、包（package）的管理与作用"><a href="#六、包（package）的管理与作用" class="headerlink" title="六、包（package）的管理与作用"></a>六、包（package）的管理与作用</h3><h3 id="七、DOS命令行下编译器操作"><a href="#七、DOS命令行下编译器操作" class="headerlink" title="七、DOS命令行下编译器操作"></a>七、DOS命令行下编译器操作</h3><h3 id="八、使用jar命令打包应用程序"><a href="#八、使用jar命令打包应用程序" class="headerlink" title="八、使用jar命令打包应用程序"></a>八、使用jar命令打包应用程序</h3><h3 id="九、数组的创建与使用"><a href="#九、数组的创建与使用" class="headerlink" title="九、数组的创建与使用"></a>九、数组的创建与使用</h3><h3 id="十、一维数组与多维数组"><a href="#十、一维数组与多维数组" class="headerlink" title="十、一维数组与多维数组"></a>十、一维数组与多维数组</h3><h3 id="十一、数组的默认初始化与内存分析"><a href="#十一、数组的默认初始化与内存分析" class="headerlink" title="十一、数组的默认初始化与内存分析"></a>十一、数组的默认初始化与内存分析</h3><h3 id="十二、数组的常见算法分析"><a href="#十二、数组的常见算法分析" class="headerlink" title="十二、数组的常见算法分析"></a>十二、数组的常见算法分析</h3><h3 id="十三、操作数组的工具类Arrays"><a href="#十三、操作数组的工具类Arrays" class="headerlink" title="十三、操作数组的工具类Arrays"></a>十三、操作数组的工具类Arrays</h3><h3 id="十四、命令行参数"><a href="#十四、命令行参数" class="headerlink" title="十四、命令行参数"></a>十四、命令行参数</h3><h3 id="十五、可变参数"><a href="#十五、可变参数" class="headerlink" title="十五、可变参数"></a>十五、可变参数</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础语法</title>
      <link href="posts/7da56k7r.html"/>
      <url>posts/7da56k7r.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、流程控制语句的介绍"><a href="#一、流程控制语句的介绍" class="headerlink" title="一、流程控制语句的介绍"></a>一、流程控制语句的介绍</h3><h3 id="二、Java编译器执行流程"><a href="#二、Java编译器执行流程" class="headerlink" title="二、Java编译器执行流程"></a>二、Java编译器执行流程</h3><h3 id="三、if分支结构"><a href="#三、if分支结构" class="headerlink" title="三、if分支结构"></a>三、if分支结构</h3><h3 id="四、switch选择结构与相关规则"><a href="#四、switch选择结构与相关规则" class="headerlink" title="四、switch选择结构与相关规则"></a>四、switch选择结构与相关规则</h3><h3 id="五、循环结构"><a href="#五、循环结构" class="headerlink" title="五、循环结构"></a>五、循环结构</h3><h3 id="六、for循环"><a href="#六、for循环" class="headerlink" title="六、for循环"></a>六、for循环</h3><h3 id="七、while循环"><a href="#七、while循环" class="headerlink" title="七、while循环"></a>七、while循环</h3><h3 id="八、do-while循环语句"><a href="#八、do-while循环语句" class="headerlink" title="八、do-while循环语句"></a>八、do-while循环语句</h3><h3 id="九、各语句性能对比与应用场景"><a href="#九、各语句性能对比与应用场景" class="headerlink" title="九、各语句性能对比与应用场景"></a>九、各语句性能对比与应用场景</h3><h3 id="十、特殊流程控制语句"><a href="#十、特殊流程控制语句" class="headerlink" title="十、特殊流程控制语句"></a>十、特殊流程控制语句</h3><h3 id="十一、方法的声明与使用"><a href="#十一、方法的声明与使用" class="headerlink" title="十一、方法的声明与使用"></a>十一、方法的声明与使用</h3><h3 id="十二、方法调用的过程分析"><a href="#十二、方法调用的过程分析" class="headerlink" title="十二、方法调用的过程分析"></a>十二、方法调用的过程分析</h3><h3 id="十三、跨类调用方法"><a href="#十三、跨类调用方法" class="headerlink" title="十三、跨类调用方法"></a>十三、跨类调用方法</h3><h3 id="十四、参数的值传递"><a href="#十四、参数的值传递" class="headerlink" title="十四、参数的值传递"></a>十四、参数的值传递</h3><h3 id="十五、方法的重载Overload"><a href="#十五、方法的重载Overload" class="headerlink" title="十五、方法的重载Overload"></a>十五、方法的重载Overload</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分支结构 </tag>
            
            <tag> 循环结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程语言的概述</title>
      <link href="posts/14w2a4e6.html"/>
      <url>posts/14w2a4e6.html</url>
      
        <content type="html"><![CDATA[<h3 id="计算机语言介绍"><a href="#计算机语言介绍" class="headerlink" title="计算机语言介绍"></a>计算机语言介绍</h3><h4 id="一、机器语言"><a href="#一、机器语言" class="headerlink" title="一、机器语言"></a><strong>一、机器语言</strong></h4><p>​        简称机器码或原生码是用二进制代码表示能让CPU直接识别和执行的机器指令的集合，属于低级语言</p><p>​    用它来编写程序是非常繁琐的工作，表现如下几点：</p><ul><li>要熟记所用计算机的全部指令代码和代码的涵义</li><li>程序员自己要处理每条指令和每一数据的存储分配和输入输出，还要记住编程过程中每步所使用的工作单元处在何种状态</li><li>编写程序花费时间比运行时间远远大于几十倍甚至几百倍</li><li>程序中全部都是”0”和”1”指令代码，直观性差，容易出错，除了厂家专业人士外，绝大多数不再去学习它</li><li>指令部分的示例</li><li>0000代表加载（LOAD）</li><li>0001代表存储（STORE）</li><li>暂存器部分的示例</li><li>0000代表暂存器A</li><li>0001代表暂存器B</li><li>存储器部分的示例</li><li>000000000000代表地址为0的存储器</li><li>000000000001代表地址为1的存储器</li><li>000000010000代表地址为16的存储器</li><li>100000000000代表地址为2^11的存储器</li><li>集成示例</li><li>0000,0000,000000010000代表LOAD A,16</li><li>0000,0001,000000000001代表LOAD B,1</li><li>0001,0001,000000010000代表STORE,B,16</li><li>0001,0001,000000000001代表STORE,B,1</li></ul><h4 id="二、汇编语言"><a href="#二、汇编语言" class="headerlink" title="二、汇编语言"></a><strong>二、汇编语言</strong></h4><ul><li><p>简称符号语言，用标识符代替机器指令的操作码，跟机器语言一样，直接对硬件操作，也属于低级语言， 一般来说只有像Inel AMD等芯片厂商应用才广泛</p></li><li><p>汇编语言的主体是汇编指令。汇编指令和机器指令的差别在于指令的表示方法上。汇编指令是机器指令便于记忆的书写格式</p></li></ul><p>​        图例：</p><p>​        操作：寄存器BX的内容送到AX中</p><p>​        1000100111011000           机器指令</p><p>​         mov    ax，bx                     汇编指令</p><p> 其特点：</p><ul><li><p> 面向机器的低级语言，通常为特定的计算机或系列计算机专门设计</p></li><li><p> 保持了机器语言的优点，具有直接和简捷的特点</p></li><li><p> 可有效地访问、控制计算机的各种硬件设备，如磁盘、存储器、CPU、I/O端口等</p></li><li><p> 目标代码简短，占用内存少，执行速度快，是高效的程序设计语言</p></li><li><p> 经常与高级语言配合使用，应用十分广泛</p></li></ul><h4 id="三、高级语言"><a href="#三、高级语言" class="headerlink" title="三、高级语言"></a><strong>三、高级语言</strong></h4><p>​        是大多数编程者的选择，由于汇编语言依赖于硬件体系，且标识符量大难记，于是人们又发明了更加易用的所谓高级语言，使一般人易于接受的文字来表示，从而让程序员写得更容易，可读性更高，以便于对电脑认知较浅的人亦可以大概明白其内容</p><p>  高级语言所编制的程序不能直接被计算机识别，必须经过转换才能被执行，按转换方式可分为2类：</p><h5 id="1、-编译类"><a href="#1、-编译类" class="headerlink" title="1、 编译类"></a>1、 编译类</h5><p>​         事先编好一个叫做编译程序的机器语言程序放在计算机中，当高级语言编的源程序输入计算机时，编译程序就把整个源程序自动翻译成用机器指令表示的目标程序</p><p>​         使用比较方便、效率较高，但源程序一旦需要修改，必须先修改再重新编译整个源程序才执行，跨平台性较差，如C、C++、Delphi等</p><p>​        图例：</p><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213164208.png?raw=true"></p><h5 id="2、-解释类"><a href="#2、-解释类" class="headerlink" title="2、 解释类"></a>2、 解释类</h5><p>​         事先编好一个叫做解释程序的机器语言程序放在计算机中，当高级语言源程序输入计算机后，解释程序自动地逐句翻译源程序，译一句执行一句。</p><p>​        使用效率比较低，依赖解释器，跨平台性好，如Python，Java，Ruby等</p><p>​        编译的结果是另外一种语言，而解释的就是一种中间语言</p><p>​        图例：</p><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213164239.png?raw=true"></p><h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a><strong>四、总结</strong></h4><h5 id="1、机器语言"><a href="#1、机器语言" class="headerlink" title="1、机器语言"></a>1、机器语言</h5><p>​     优点是最底层，速度最快，缺点是最复杂，开发效率最低</p><h5 id="2、汇编语言"><a href="#2、汇编语言" class="headerlink" title="2、汇编语言"></a>2、汇编语言</h5><p>​     优点是比较底层，速度最快，缺点是复杂，开发效率最低</p><h5 id="3、高级语言"><a href="#3、高级语言" class="headerlink" title="3、高级语言"></a>3、高级语言</h5><p>​      编译型语言执行速度快，不依赖语言环境运行，跨平台差</p><p>​      解释型跨平台好，一分代码，到处可用，开发效率高，缺点是执行速度慢，依赖解释器运行</p><h3 id="Java语言的前世今生"><a href="#Java语言的前世今生" class="headerlink" title="Java语言的前世今生"></a>Java语言的前世今生</h3><h4 id="一、Java语言概述"><a href="#一、Java语言概述" class="headerlink" title="一、Java语言概述"></a>一、Java语言概述</h4><ul><li>是SUN(Stanford University Network，斯坦福大学网络公司 ) 1995年推出的一门高级编程语言</li><li>是一种面向Internet的编程语言。Java一开始富有吸引力是因为Java程序可以在Web浏览器中运行。这些Java程序被称为Java小程序（applet）。applet使用现代的图形用户界面与Web用户进行交互。 applet内嵌在HTML代码中</li><li>随着Java技术在web方面的不断成熟，已经成为Web应用程序的首选开发语言</li><li>后台开发语言：Java、PHP、Python、Go、Node.js</li></ul><h4 id="二、Java简史"><a href="#二、Java简史" class="headerlink" title="二、Java简史"></a>二、Java简史</h4><p>图例：</p><p><img src="https://img-blog.csdnimg.cn/20191117210522275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzNDUyMzg1,size_16,color_FFFFFF,t_70" alt="java简史"></p><h3 id="Java技术体系平台"><a href="#Java技术体系平台" class="headerlink" title="Java技术体系平台"></a>Java技术体系平台</h3><h5 id="一、Java-SE-Java-Standard-Edition-标准版"><a href="#一、Java-SE-Java-Standard-Edition-标准版" class="headerlink" title="一、Java SE(Java Standard Edition)标准版"></a>一、Java SE(Java Standard Edition)标准版</h5><p>支持面向桌面级应用（如Windows下的应用程序）的Java平台，提供了完整的Java核 心API，此版本以前称为J2SE</p><h5 id="二、Java-EE-Java-Enterprise-Edition-企业版"><a href="#二、Java-EE-Java-Enterprise-Edition-企业版" class="headerlink" title="二、Java EE(Java Enterprise Edition)企业版"></a>二、Java EE(Java Enterprise Edition)企业版</h5><p>是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如<br>:Servlet 、Jsp等，主要针对于Web应用程序开发。版本以前称为J2EE</p><h5 id="三、Java-ME-Java-Micro-Edition-小型版"><a href="#三、Java-ME-Java-Micro-Edition-小型版" class="headerlink" title="三、Java ME(Java Micro Edition)小型版"></a>三、Java ME(Java Micro Edition)小型版</h5><p>支持Java程序运行在移动终端（手机、PDA）上的平台，对Java API有所精简，并加入了针对移动终端的支持，此版本以前称为J2ME</p><h5 id="四、Java-Card"><a href="#四、Java-Card" class="headerlink" title="四、Java Card"></a>四、Java Card</h5><p>支持一些Java小程序（Applets）运行在小内存设备（如智能卡）上的平台</p><h3 id="JDK的安装与环境配置"><a href="#JDK的安装与环境配置" class="headerlink" title="JDK的安装与环境配置"></a>JDK的安装与环境配置</h3><h4 id="一、JDK下载及安装"><a href="#一、JDK下载及安装" class="headerlink" title="一、JDK下载及安装"></a>一、JDK下载及安装</h4><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143209.png?raw=true"></p><h4 id="二、JDK环境变量配置及测试"><a href="#二、JDK环境变量配置及测试" class="headerlink" title="二、JDK环境变量配置及测试"></a>二、JDK环境变量配置及测试</h4><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213163534.png?raw=true"></p><h3 id="JDK、JRE、JVM之间的关系"><a href="#JDK、JRE、JVM之间的关系" class="headerlink" title="JDK、JRE、JVM之间的关系"></a>JDK、JRE、JVM之间的关系</h3><p>• javac.exe - 编译器，主要用于将高级Java源代码翻译成字节码文件 </p><p>• java.exe - 解释器，主要用于启动JVM对字节码文件进行解释并执行</p><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143935.png?raw=true"></p><h3 id="Java核心机制及JVM运行原理"><a href="#Java核心机制及JVM运行原理" class="headerlink" title="Java核心机制及JVM运行原理"></a>Java核心机制及JVM运行原理</h3><h4 id="一、Java两种核心机制"><a href="#一、Java两种核心机制" class="headerlink" title="一、Java两种核心机制"></a>一、Java两种核心机制</h4><ul><li><h5 id="Java虚拟机-Java-Virtal-Machine"><a href="#Java虚拟机-Java-Virtal-Machine" class="headerlink" title="Java虚拟机 (Java Virtal Machine)"></a>Java虚拟机 (Java Virtal Machine)</h5></li></ul><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213160814.png?raw=true"></p><ul><li><h5 id="垃圾收集机制-Garbage-Collection"><a href="#垃圾收集机制-Garbage-Collection" class="headerlink" title="垃圾收集机制 (Garbage Collection)"></a>垃圾收集机制 (Garbage Collection)</h5><p>不再使用的内存空间应回收—— 垃圾回收</p><p>在C/C++等语言中，由程序员负责回收无用内存。Java 语言消除了程序员回收无用内存空间的责任：它提供一种系统级线程跟踪存储空间的分配情况。并在JVM空闲时，检查并释放那些可被释放的存储空间</p><p>垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预</p></li></ul><h3 id="Java程序执行原理"><a href="#Java程序执行原理" class="headerlink" title="Java程序执行原理"></a>Java程序执行原理</h3><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213163759.png?raw=true"></p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>​    用于注解说明解释程序的文字就是注释</p><p>​    Java中的注释类型：</p><p>​     单行注释</p><p>​    多行注释</p><p>​    文档注释 (java特有) </p><p>​    提高了代码的阅读性；调试程序的重要方法。 </p><p>​    注释是一个程序员必须要具有的良好编程习惯。</p><p>​    将自己的思想通过注释先整理出来，再用代码去体现</p><p>​    <strong>单行注释</strong></p><p>​    格式：</p><p>​     //注释文字</p><p>​    <strong>多行注释</strong></p><p>​    格式： </p><p>​    /* 注释文字 */ </p><p>​    注：</p><p>​    对于单行和多行注释，被注释的文字，不会被JVM（java虚拟机）解释执行。</p><p>​    多行注释里面不允许有多行注释嵌套</p><p>​    <strong>文档注释（Java特有）</strong></p><p>​    格式：</p><p><strong>**</strong>/</p><p><strong>@author</strong> <strong>指定</strong>java程序的作者</p><p><strong>@version</strong> <strong>指定源文件的版本</strong></p><p>*<strong>/</strong> </p><p>​    注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形</p><p>​    式体现的该程序的说明文</p><p>​    操作方式</p><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143211.jpg?raw=true" alt="文档注释"></p><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143212.jpg?raw=true" alt="文档注释"></p><pre><code class="java"> /** *HelloChina *@author YoYopupunsi *@version V1.0 *11:19 2021/1/30 0030 *备注：验证各类注释的注意事项 */public class HelloChina &#123;    public static void main(String[] args)&#123;        System.out.println(&quot;你好，中国！&quot;);    &#125;&#125;//验证：单行和多行注释，被注释的文字，不会被JVM（java虚拟机）解释执行//验证：多行注释不允许嵌套使用//单行注释不会被JVM解释执行/*多行注释不会被JVM解释执行 *//*验证：多行注释不允许嵌套使用你好中国HelloChina*///java: 需要class, interface或enum,多行注释不允许嵌套使用</code></pre><h3 id="开发第一个Java应用程序HelloWorld"><a href="#开发第一个Java应用程序HelloWorld" class="headerlink" title="开发第一个Java应用程序HelloWorld"></a>开发第一个Java应用程序HelloWorld</h3><pre><code class="java">public class one_code/*类名*/ &#123;/*类体*/    public static void main/*主方法名程序的入口*/(String[]args)&#123;/*主方法体*/        System.out.println(&quot;HelloWorld&quot;);//自动换行        System.out.print(&quot;我爱中国&quot;);//不换行        System.out.println(&quot;HelloChina&quot;);    &#125;&#125;/*对第一个程序HelloWorld总结：1.java程序编写-&gt;编译-&gt;运行的过程(1)编写：编写java代码保存.java结尾的源文件(2)编译：使用javac.exe命令编译java源文件生成.class的字节码文件,格式：javac 源文件名.javajavac one_code.java，后缀.java为了检验源文件是否编写错误(3)运行：使用java.exe命令解释运行.class的字节码文件，格式：java 类java one_code jvm解释运行字节码文件2.class 类名&#123;类体&#125;  main()主方法名，程序的入口&#123;主方法体&#125;3. 输出语句：System.out.println():先输出数据，然后换行System.out.print():只输出数据4.每一行执行语句都以&quot;;&quot;结束在java语言规范中，分号代表一个语句的结束。所以，即使分号前面没有任何内容，那么一个分号其实也代表一个语句（空语句）。5.编译的过程：编译以后，会生成一个或多个字节码文件。字节码文件的文件名与java源文件中的类名相同6.关于作用域的理解(1)个人理解：‘&#123;&#125;’花括号‘&#123;’是作用域的起点，&#39;&#125;&#39;是作用域的终点.(2)百度：中间部分就是一个代码块，代码块决定其中定义的变量的作用域，代码块由若干语句组成，必须用大括号括起来，形成一个复合语句，多个复合语句可以嵌套在另外的一对大括号中形成更复杂的复合语句.说得简单点就是在哪个大括号中声明的变量其作用域就是该大括号范围内.代码块决定了变量的作用域，作用域决定了变量的“可见性”以及“存在时间”. */// 7.验证java源文件是否可以声明多个class？// 在一个java源文件中可以声明多个class。但是，只能最多有一个类声明为public的。// 而且要求声明为public的类的类名必须与源文件名相同。///*public class he&#123;&#125;编译错误：类he是公共的，应在名为he.java的文件中声明 */class woman&#123;&#125;class man&#123;&#125;</code></pre><h3 id="Java-Code-Style"><a href="#Java-Code-Style" class="headerlink" title="Java Code Style"></a>Java Code Style</h3><p>代码整洁之道(已整理，关于标识符)</p><p>第2章 有意义的命名<br>2.1 介绍<br>软件中随处可见命名。我们给变量、函数、参数、类和包命名。我们给源代码及源代码所在目录命名<br>这么多命名要做，不妨做好它。下文列出了取个好名字的几条简单规则</p><p>2.2 名副其实,见名知意<br>     变量名太随意，haha、list1、ok、theList 这些都没啥意义</p><p>2.3 避免误导<br>     包含List、import、java等类名、关键字或特殊字；<br>     字母o与数字0，字母l与数字1等<br>     提防使用不同之处较小的名称。比如：XYZControllerForEfficientHandlingOfStrings与XYZControllerForEfficientStorageOfStrings</p><p>2.4 做有意义的区分<br>     反面教材，变量名：a1、a2、a3<br>     避免冗余，不要出现Variable、表字段中避免出现table、字符串避免出现nameString，直接name就行，知道是字符串类型<br>     再比如：定义了两个类：Customer类和CustomerObject类，如何区分？<br>         定义了三个方法：getActiveAccount()、getActiveAccounts()、getActiveAccountInfo()，如何区分？</p><p>2.5 使用读得出来的名称<br>     不要使用自己拼凑出来的单词，比如：xsxm(学生姓名)；genymdhms(生成日期，年、月、日、时、分、秒)<br>     所谓的驼峰命名法，尽量使用完整的单词</p><p>2.6 使用可搜索的名称<br>     一些常量，最好不直接使用数字，而指定一个变量名，这个变量名可以便于搜索到.<br>     比如：找MAX_CLASSES_PER_STUDENT很容易，但想找数字7就麻烦了。</p><p>2.7 避免使用编码<br>     2.7.1 匈牙利语标记法<br>           即变量名表明该变量数据类型的小写字母开始。例如，szCmdLine的前缀sz表示“以零结束的字符串”<br>     2.7.2 成员前缀<br>          避免使用前缀，但是Android中一个比较好的喜欢用m表示私有等，个人感觉比较好<br>     2.7.3 接口和实现<br>          作者不喜欢把接口使用I来开头，实现也希望只是在后面添加Imp</p><p>2.8 避免思维映射<br>     比如传统上惯用单字母名称做循环计数器。所以就不要给一些非计数器的变量命名为：i、j、k等</p><p>2.9  类名<br>     类名与对象名应该是名词与名词短语。如Customer、WikiPage、Account和AddressParser。避免使用Data或Info这样的类名。<br>     不能使动词。比如：Manage、Process</p><p>2.10 方法名<br>     方法名应当是动词或者动词短语。如postPayment、deletePage或save</p><p>2.11 别扮可爱<br>     有的变量名叫haha、banana<br>     别用eatMyShorts()表示abort()</p><p>2.12 每个概念对应一个词<br>     项目中同时出现controllers与managers，为什么不统一使用其中一种？<br>     对于那些会用到你代码的程序员，一以贯之的命名法简直就是天降福音。</p><p>2.13 别用双关语<br>     有时可能使用add并不合适，比例insert、append。add表示完整的新添加的含义。     </p><p>2.14 使用解决方案领域名称<br>     看代码的都是程序员，所以尽量用那些计算机科学术语、算法名、模式名、数学术语，<br>     依据问题所涉领域来命名不算是聪明的做法</p><p>2.15 使用源自所涉问题领域的名称<br>     如果不能用程序员熟悉的术语来给手头的工作命名，就采用从所涉问题领域而来的名称吧。<br>     至少，负责维护代码的程序员就能去请教领域专家了</p><p>2.16 添加有意义的语境<br>     可以把相关的变量放到一个类中，使用这个类来表明语境</p><p>2.17 不要添加没用的语境<br>     名字中带有项目的缩写，这样完全没有必要。比如有一个名为“加油站豪华版”（Gas Station Deluxe）的项目，<br>     在其中给每个类添加GSD前缀就不是什么好策略</p><p>2.18 最后的话<br>     取好名字最难的地方在于需要良好的描述技巧和共有文化背景</p><h3 id="变量的声明和使用"><a href="#变量的声明和使用" class="headerlink" title="变量的声明和使用"></a>变量的声明和使用</h3><h4 id="一、标识符"><a href="#一、标识符" class="headerlink" title="一、标识符"></a>一、标识符</h4><h5 id="1、标识符"><a href="#1、标识符" class="headerlink" title="1、标识符"></a>1、标识符</h5><ul><li>Java 对各种<strong>变量</strong>、<strong>方法</strong>和<strong>类</strong>等要素命名时使用的字符序列称为标识符</li><li><strong>技巧：凡是自己可以起名字的地方都叫标识符</strong>。 </li></ul><h5 id="2、定义合法标识符规则"><a href="#2、定义合法标识符规则" class="headerlink" title="2、定义合法标识符规则"></a>2、定义合法标识符规则</h5><ul><li><p><strong>由26个英文字母大小写，0-9 _或 $组成</strong></p></li><li><p><strong>数字不可以开头</strong></p></li><li><p><strong>不可以使用关键字和保留字，但能包含关键字和保留字</strong></p></li><li><p><strong>Java中严格区分大小写，长度无限制</strong></p></li><li><p><strong>标识符不能包含空格</strong></p></li></ul><h5 id="3、Java中的名称命名规范："><a href="#3、Java中的名称命名规范：" class="headerlink" title="3、Java中的名称命名规范："></a>3、Java中的名称命名规范：</h5><ul><li><p><strong>包名</strong>：多单词组成时所有字母都小写：aaabbbccc</p></li><li><p><strong>类名、接口名</strong>：多单词组成时，所有单词的首字母大写：AaaBbbCcc</p></li><li><p><strong>变量名、方法名</strong>：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：aaaBbbCcc</p></li><li><p><strong>常量名</strong>：所有字母都大写。多单词时每个单词用下划线连接：AAA_BBB_CCC</p></li><li><p>注意1：在起名字时，为了提高阅读性，要尽量有意义，“见名知意”。</p></li><li><p>注意2：java采用unicode字符集，因此标识符也可以使用汉字声明，但是不建议使用。</p></li></ul><h4 id="二、变量的概念"><a href="#二、变量的概念" class="headerlink" title="二、变量的概念"></a>二、变量的概念</h4><ul><li>内存中的一个存储区域</li><li>该区域的数据可以在同一类型范围内不断变化</li><li>变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值</li></ul><h4 id="三、变量的作用"><a href="#三、变量的作用" class="headerlink" title="三、变量的作用"></a>三、变量的作用</h4><ul><li>用于在内存中保存数据</li></ul><h4 id="四、变量注意事项"><a href="#四、变量注意事项" class="headerlink" title="四、变量注意事项"></a>四、变量注意事项</h4><ul><li>Java中每个变量必须先声明，后使用</li><li>使用变量名来访问这块区域的数据</li><li>变量的作用域：其定义所在的一对{ }内 </li><li>变量只有在其作用域内才有效</li><li>同一个作用域内，不能定义重名的变量</li></ul><h4 id="五、声明变量"><a href="#五、声明变量" class="headerlink" title="五、声明变量"></a>五、声明变量</h4><ul><li>语法：数据类型    变量名称</li><li>例如：int var;</li></ul><h4 id="六、变量的赋值"><a href="#六、变量的赋值" class="headerlink" title="六、变量的赋值"></a>六、变量的赋值</h4><ul><li>语法：变量名称 = 值</li><li>例如：var = 10;</li></ul><h4 id="七、声明和赋值变量"><a href="#七、声明和赋值变量" class="headerlink" title="七、声明和赋值变量"></a>七、声明和赋值变量</h4><ul><li><p>语法： 数据类型    变量名 = 初始化值</p></li><li><p>例如：int var = 10;</p></li><li><p>对于每一种数据都定义了明确的具体数据类型（强类型语言），在内存中分</p><p>配了不同大小的内存空间</p></li></ul><h4 id="八、变量的分类-按声明的位置的不同"><a href="#八、变量的分类-按声明的位置的不同" class="headerlink" title="八、变量的分类-按声明的位置的不同"></a>八、变量的分类-按声明的位置的不同</h4><ul><li><p><strong>在方法体外，类体内声明的变量称为成员变量</strong> </p></li><li><p><strong>在方法体内部声明的变量称为局部变量</strong></p></li><li><p><strong>注意：二者在初始化值方面的异同:</strong></p></li></ul><p>​       <strong>同：都有生命周期</strong>     <strong>异：局部变量除形参外，需显式初始化</strong></p><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143213.png?raw=true" alt="变量的分类"></p><h5 id="变量-代码："><a href="#变量-代码：" class="headerlink" title="变量-代码："></a>变量-代码：</h5><pre><code class="java">/** * @Author: YoYopupunsi * @Description: * @Date: Created in 11:00 2021/2/1 0001 * @Modified By: *//*变量的使用1. java定义变量的格式：数据类型 变量名 = 变量值;数据类型 变量名;变量名 = 变量值;2. 说明：   ① 变量必须先声明，后使用   ② 变量都定义在其作用域内。在作用域内，它是有效的。换句话说，出了作用域，就失效了   ③ 同一个作用域内，不可以声明两个同名的变量*/public class variable_code &#123;    public static void main(String[] args) &#123;        //1.变量的定义(输入)        int Var = 10;        //2.变量的使用（输出）        System.out.println(Var);        //编译错误：使用Var之前并未定义过Var        //System.out.println(Var);        //3.变量的声明        //int Var;        //编译错误：使用Var之前并未赋值过Var        //System.out.println(Var);        //4.变量的赋值        //Var = 1001;        //编译不通过        //System.out.println(Var);        //5.不可以在同一个作用域内定义同名的变量        //int Var = 22;    &#125;&#125;</code></pre><h5 id="案例题目："><a href="#案例题目：" class="headerlink" title="案例题目："></a><strong>案例题目：</strong></h5><p>• 提示用户从键盘输入自己的姓名和年龄信息并打印出来</p><pre><code class="java">/** * @Author: YoYopupunsi * @Description: * @Date: Created in 12:16 2021/2/1 0001 * @Modified By: *//** 变量案例：提示用户从键盘输入自己的姓名和年龄信息并打印出来*分析：*1.声明两个变量用于记录姓名和年龄信息*2.提示用户从键盘输入姓名和年龄信息并放入到变量中   变量随使用随声明*3.打印变量的数值     尽可能减少重复的代码* */import java.util.Scanner;public class VariableCase_1 &#123;    public static void main(String[] args) &#123;        // 1.声明两个变量用于记录姓名和年龄信息        //String name;        //int age;        // 2.提示用户从键盘输入姓名和年龄信息并放入到变量中        System.out.println(&quot;请输入您的姓名：&quot;);        // 创建一个扫描器来扫描键盘输入的内容  System.in代表键盘输入        Scanner sc = new Scanner(System.in);        // 通过扫描器读取一个字符串数据放入变量name中        String name = sc.next();        System.out.println(&quot;请输入您的年龄：&quot;);        Scanner sc1 = new Scanner(System.in);        // 通过扫描器读取一个整数数据放入变量age中        int age = sc1.nextInt();        // 3.打印变量的数值        System.out.println(&quot; 姓名： &quot; + name + &quot;\n 年龄： &quot; + age);    &#125;&#125;</code></pre><h3 id="数据类型的分类"><a href="#数据类型的分类" class="headerlink" title="数据类型的分类"></a>数据类型的分类</h3><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143214.png?raw=true"></p><h4 id="一、进制"><a href="#一、进制" class="headerlink" title="一、进制"></a>一、进制</h4><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143215.png?raw=true"></p><ul><li>正十进制转换为二进制的方式：</li></ul><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143216.jpg?raw=true"></p><ul><li>正二进制转换为十进制的方式：</li></ul><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143217.jpg?raw=true"></p><ul><li>负十进制转换为二进制的方式：</li></ul><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143218.jpg?raw=true"></p><ul><li>负二进制转换为十进制的方式：</li></ul><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143219.jpg?raw=true"></p><ul><li><strong>单个字节表示的范围：</strong></li></ul><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143220.jpg?raw=true"></p><h4 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h4><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143221.png?raw=true"></p><ul><li>转义字符<img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143906.png?raw=true"></li><li>ASCII表<img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143907.png?raw=true"></li><li>相关代码<img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143908.png?raw=true"></li></ul><h4 id="三、基本数据类型之间的转换"><a href="#三、基本数据类型之间的转换" class="headerlink" title="三、基本数据类型之间的转换"></a>三、基本数据类型之间的转换</h4><ul><li><p>自动数据类型转换：表示将变量b的数值赋值给变量s，并覆盖变量s中原来的数值，相当于从byte类型到short类型的转换，小到大自动转换</p><p>![自动数据类型转换](D:\project\project_java\01_Java_模块一_一阶段\02_任务二： 变量和数据类型\04_picture\05_image-20210204102841415.png)</p></li><li><p>强制数据类型转换：表示将变量i的数值赋值给变量s，并覆盖变量s中原来的数值，相当于从int类型到short类型的转换，大到小强制转换（精度会有损失）</p></li><li><p>相关代码</p><pre><code class="java">/** * @Author: YoYopupunsi * @Description: * @Date: Created in 10:56 2021/2/2 0002 * @Modified By: */public class DataTypeConversion &#123;    public static void main(String[] args)&#123;        //1.首先声明变量接收各个数据类型        byte b = 1;        short s = 12;        int i = 127;        long l = 1234567891011L;        char c = &#39;a&#39;;        boolean bo1 = true;        boolean bo2 = false;        float f = 3.14159f;        double d = 3.141592653545;        //2.先打印各个数据类型的值        System.out.println(&quot;b的值为：&quot; + b);//127        System.out.println(&quot;s的值为：&quot; + s);//32767        System.out.println(&quot;i的值为：&quot; + i);//388883        System.out.println(&quot;l的值为：&quot; + l);//1234567891011L        System.out.println(&quot;c的值为：&quot; + c);//a        System.out.println(&quot;bo1的值为：&quot; + bo1);//true        System.out.println(&quot;bo2的值为：&quot; + bo2);//false        System.out.println(&quot;f的值为：&quot; + f);//3.14159        System.out.println(&quot;d的值为：&quot; + d);//3.141592653545        //3.首先测试自动数据类型转换：表示将变量b的数值赋值给变量s，并覆盖变量s中原来的数值，相当于从byte类型到short类型的转换，小到大自动转换        s = b;//        System.out.println(&quot;b的值为：&quot; + b);//1        System.out.println(&quot;s的值为：&quot; + s);//1        i =s;        System.out.println(&quot;i的值为：&quot; + i);//1        System.out.println(&quot;s的值为：&quot; + s);//1        //4.测试强制数据类型转换：表示将变量i的数值赋值给变量s，并覆盖变量s中原来的数值，相当于从int类型到short类型的转换，大到小强制转换        //s = i;//java: 不兼容的类型: 从int转换到short可能会有损失        //正确格式：        i = 127;        s = (short) i;        System.out.println(&quot;i的值为：&quot; + i);        System.out.println(&quot;s的值为：&quot; + s);        System.out.println(&quot;s的值为：&quot; + (int) s);    &#125;&#125;</code></pre></li></ul><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="一-算术运算符"><a href="#一-算术运算符" class="headerlink" title="一.算术运算符"></a>一.算术运算符</h4><p>• + 表示加法运算符</p><p>• - 表示减法运算符</p><p>• * 表示乘法运算符</p><p>• / 表示除法运算符</p><p>• % 表示取模/取余运算符</p><h4 id="二-字符串连接运算符"><a href="#二-字符串连接运算符" class="headerlink" title="二.字符串连接运算符"></a>二.字符串连接运算符</h4><p>• + 可以实现字符串的连接。同时可以实现字符串与其他数据类型“相连”。</p><h5 id="算术运算符几个问题的验证-如下列代码："><a href="#算术运算符几个问题的验证-如下列代码：" class="headerlink" title="算术运算符几个问题的验证(如下列代码：)"></a><strong>算术运算符几个问题的验证(如下列代码：)</strong></h5><p><u><strong>1.若希望保留小数部分该如何处理？</strong></u></p><p>处理方式一：使用强制类型转换将其中一个操作数转换为double类型再运算即可</p><p>处理方式二：使用 变量*1.0 打印即可</p><p><strong><u>2.算术运算符中%能对负数取模吗？取模一定为正数吗？验证：</u></strong></p><p>结论：负数参与的取模运算规则：先忽略负号，按照正数运算之后，被取模的数是正数结果就取正，反之取负。（注：(-2)%5中被取模数是-2,(-5)%2中被取模数是-1）</p><p><strong><u>3.对于除号“/”，它的整数除和小数除的区别是什么？验证：</u></strong></p><p>结论：整数之间做除法时，只保留整数部分而舍弃小数部分，整数与小数相除的结果为小数，小数除的结果为小数</p><p>*<em><u>4.=  +=   -=   <em>=  /=  %=   里面隐藏了强制类型转换</u></em></em></p><p>byte x += 10;     —&gt; x = (byte)(x + 10);</p><h5 id="案例题目-提示用户输入正整数类型的秒数，拆分秒数后输出x小时x分x秒。-如：输入xxxx，输出x小时x分x秒。"><a href="#案例题目-提示用户输入正整数类型的秒数，拆分秒数后输出x小时x分x秒。-如：输入xxxx，输出x小时x分x秒。" class="headerlink" title="**案例题目:**提示用户输入正整数类型的秒数，拆分秒数后输出x小时x分x秒。 如：输入xxxx，输出x小时x分x秒。"></a>**案例题目:**提示用户输入正整数类型的秒数，拆分秒数后输出x小时x分x秒。 如：输入xxxx，输出x小时x分x秒。</h5><pre><code class="java">import java.util.Scanner;public class ArithmeticOperatorsAndCases &#123;    public static void main(String[] args) &#123;        //算术运算学习：        //1.声明两个int变量并初始化        //int Ari1        //int Ari2        int Ari1 = 20, Ari2 = 10;        //分别为+ - * / %        int Add = Ari1 + Ari2;//声明一个变量Add记录Ari1，Ari2的和        int Sub = Ari1 - Ari2;//声明一个变量Sub记录Ari1，Ari2的差        int Mul = Ari1 * Ari2;//声明一个变量Mul记录Ari1，Ari2的乘积        int Div = Ari1 / Ari2;//声明一个变量Div记录Ari1，Ari2的除法        int Sur = Ari1 % Ari2;//声明一个变量Sur记录Ari1，Ari2的取余        System.out.println(&quot;Ari1，Ari2的和为：&quot; + Add + &quot;\nAri1，Ari2的差为：&quot; + Sub + &quot;\nAri1，Ari2的乘积为：&quot; + Mul + &quot;\nAri1，Ari2的除法为：&quot; + Div + &quot;\nAri1，Ari2的取余为：&quot; + Sur);        //Ari1，Ari2的和为：30  Ari1，Ari2的差为：10  Ari1，Ari2的乘积为：200  Ari1，Ari2的除法为：2  Ari1，Ari2的取余为：0        //若希望保留小数部分该如何处理？        //处理方式一：使用强制类型转换将其中一个操作数转换为double类型再运算即可        System.out.println(&quot;Ari1，Ari2的和为：&quot; + (double)Add);        //处理方式二：使用 变量*1.0 打印即可        System.out.println(&quot;Ari1，Ari2的和为：&quot; + Add*1.0);        //算术运算符中%能对负数取模吗？取模一定为正数吗？验证：        //1.首先声明并赋值两个整数型的变量记录        int Sur1 = 5,Sur2 = -2;        //2.声明一个变量Sur3记录Sur1，Sur2的取模        int Sur3 = Sur1 % Sur2;        System.out.println(&quot;Sur1，Sur2的取模为:&quot; + Sur3);//Sur1，Sur2的取模为:1        //3.声明一个变量Sur4记录Sur1，Sur2的取模        int Sur4 = Sur2 % Sur1;        System.out.println(&quot;Sur1，Sur2的取模为:&quot; + Sur4);//Sur1，Sur2的取模为:-2        //4.声明并赋值两个整数型的变量记录        int Sur5 = -5,Sur6 = 2;        //5.声明一个变量Sur8记录Sur5，Sur6的取模        int Sur7 = Sur5 % Sur6;        System.out.println(&quot;Sur5，Sur6的取模为:&quot; + Sur7);//Sur5，Sur6的取模为:-1        //6.声明一个变量Sur8记录Sur5，Sur6的取模        int Sur8 = Sur6 % Sur5;        System.out.println(&quot;Sur5，Sur6的取模为:&quot; + Sur8);//Sur5，Sur6的取模为:2        //结论：负数参与的取模运算规则：先忽略负号，按照正数运算之后，被取模的数是正数结果就取正，反之取负。（注：(-2)%5中被取模数是-2,(-5)%2中被取模数是-1）        //对于除号“/”，它的整数除和小数除的区别是什么？        double d = 10.2,e = 5.2;        int i=314;i=i/1000*1000;        System.out.println(&quot;double的除法:&quot; + d/e);//1.9615384615384612        System.out.println(&quot;double/int的除法:&quot; + d/Ari2);//1.02        System.out.println(&quot;i为:&quot; + i);//300        //结论：整数之间做除法时，只保留整数部分而舍弃小数部分，整数与小数相除的结果为小数，小数除的结果为小数。        //案例题目：• 提示用户输入正整数类型的秒数，拆分秒数后输出x小时x分x秒。• 如：输入xxxx，输出x小时x分x秒。        //1.提示用户输入正整数类型的秒数        System.out.println(&quot;请您输入正整数类型的秒数：&quot;);        //2.使用变量记录用户输入的正整数型的秒数        Scanner sc = new Scanner(System.in);        int Sec1 = sc.nextInt();        //3.将正整数的秒数拆分为时分秒后并使用变量记录        int Hour = Sec1 / 60 / 60;        int Minute = Sec1 % 3600 /60;        int Second = Sec1 % 60;        System.out.println(&quot;时间为：&quot; + Hour + &quot;小时&quot; + Minute + &quot;分钟&quot; + Second + &quot;秒&quot;);    &#125;&#125;</code></pre><h4 id="三、关系-比较运算符"><a href="#三、关系-比较运算符" class="headerlink" title="三、关系/比较运算符"></a>三、关系/比较运算符</h4><p>• &gt; 表示是否大于运算符 </p><p>&gt;= 表示是否大于等于运算符</p><p>• &lt; 表示是否小于运算符 </p><p>&lt;= 表示是否小于等于运算符</p><p>• == 表示是否等于运算符 </p><p>!= 表示是否不等于运算符</p><p>• 所有以关系运算符作为最终运算的表达式结果一定是boolean类型。</p><p>相关代码：</p><pre><code class="java">/** * @Author: YoYopupunsi * @Description: * @Date: Created in 2:26 2021/2/3 0003 * @Modified By: */import java.util.Scanner;public class ComparisonOperatorsAndCases &#123;    public static void main(String[] args)&#123;        // 1.声明两个int类型的变量并初始化        int i = 5;        int j = 2;        // 2.使用变量实现关系运算符的使用并打印结果        boolean k = i &gt; j;        System.out.println(&quot;k = &quot; + k); // k = true        System.out.println(i &gt; j);   // 是否大于      true        System.out.println(i &gt;= j);  // 是否大于或等于 true        System.out.println(i &lt; j);   // 是否小于    false        System.out.println(i &lt;= j);  // 是否小于等于 false        System.out.println(i == j);  // 是否等于    false        System.out.println(i != j);  // 是否不等于  true        //1.请用户输入一个整数        System.out.println(&quot;请您输入一个整数：&quot;);        Scanner sc = new Scanner(System.in);        //2.声明一个变量记录用户输入的整数        int l = sc.nextInt();        //3.声明一个布尔类型的变量判断正负        boolean d = l&lt;0;        System.out.println(&quot;d=&quot;+ d);        System.out.println(l&lt;0);    &#125;&#125;</code></pre><h4 id="四、自增减运算符"><a href="#四、自增减运算符" class="headerlink" title="四、自增减运算符"></a>四、自增减运算符</h4><ul><li><p>++a</p><pre><code>自增（前）：先运算后取值      a=2;b=++a;          a=3;b=3</code></pre></li><li><p>a++</p><pre><code>自增（后）：先取值后运算      a=2;b=a++;          a=3;b=2</code></pre></li><li><p>–a<br>自减（前）：先运算后取值</p><pre><code>a=2;b=- -a    a=1;b=1</code></pre></li><li><p>a- -<br>自减（后）：先取值后运算</p><pre><code>a=2;b=a- -    a=1;b=2</code></pre><p>自增减运算符只能用于变量，常数不可以使用</p></li><li><p>图片</p></li><li><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143847.png?raw=true"></p></li><li><p>相关代码</p><pre><code class="java">public class SelfTest &#123;public static void main(String[] args) &#123;        // 1.声明一个int类型的变量并初始化        int ia = 10;        // 2.打印变量的数值        System.out.println(&quot;ia = &quot; + ia); // ia = 10                System.out.println(&quot;---------------------------------------------&quot;);        // 3.实现自增减运算符的使用        // 表示让变量ia自身的数值加1，并覆盖该变量原来的数值           ia++;   // ia = ia + 1;        System.out.println(&quot;ia = &quot; + ia); // ia = 11                // 表示让变量ia自身的数值加1，并覆盖该变量原来的数值          ++ia;        System.out.println(&quot;ia = &quot; + ia); // ia = 12                // 表示让变量ia自身的数值减1，并覆盖该变量原来的数值        --ia;        System.out.println(&quot;ia = &quot; + ia); // ia = 11                ia--;        System.out.println(&quot;ia = &quot; + ia); // ia = 10                System.out.println(&quot;---------------------------------------------&quot;);        // 4.简单的变换        // 其中ia++这个整体叫做表达式   其中ia叫做操作数/变量       也就是ia++和ia表示不同的含义，因此所占的内存空间应该不同        // 下面的代码是在打印表达式的结果        // 后++表示先让变量ia的数值作为整个表达式的最终结果，然后再让ia变量自身的数值加1        System.out.println(ia++);         // 10        System.out.println(&quot;ia = &quot; + ia); // 11        // 前++表示先让变量自身的数值加1，然后再让变量的数值作为整个表达式的结果        System.out.println(++ia);         // 12        System.out.println(&quot;ia = &quot; + ia); // 12                System.out.println(&quot;---------------------------------------------&quot;);        // 5.笔试考点        int ib = ia++;        System.out.println(&quot;ib = &quot; + ib); // 12        System.out.println(&quot;ia = &quot; + ia); // 13        int ic = ++ia;        System.out.println(&quot;ic = &quot; + ic); // 14        System.out.println(&quot;ia = &quot; + ia); // 14                //                  14  + 16        System.out.println(ia++ + ++ia);  // 30        System.out.println(&quot;ia = &quot; + ia); // 16            &#125;&#125;</code></pre></li></ul><h4 id="五、逻辑运算符"><a href="#五、逻辑运算符" class="headerlink" title="五、逻辑运算符"></a>五、逻辑运算符</h4><p>逻辑运算符的操作数均为boolean表达式</p><h5 id="amp-amp-表示逻辑与运算符"><a href="#amp-amp-表示逻辑与运算符" class="headerlink" title="&amp;&amp; 表示逻辑与运算符"></a>&amp;&amp; 表示逻辑与运算符</h5><p>相当于”并且”，同真为真，一假为假</p><h5 id="表示逻辑或运算符"><a href="#表示逻辑或运算符" class="headerlink" title="|| 表示逻辑或运算符"></a>|| 表示逻辑或运算符</h5><p>相当于”或者”，一真为真，同假为假</p><h5 id="表示逻辑非运算符"><a href="#表示逻辑非运算符" class="headerlink" title="! 表示逻辑非运算符"></a>! 表示逻辑非运算符</h5><p>相当于”取反”，真为假，假为真</p><h5 id="amp-amp-逻辑短路"><a href="#amp-amp-逻辑短路" class="headerlink" title="&amp;&amp;   ||  逻辑短路"></a>&amp;&amp;   ||  逻辑短路</h5><p>​    • 对于逻辑与运算符来说，若第一个表达式为假则结果为假，此时跳过第二个表达式；</p><p>​    • 对于逻辑或运算符来说，若第一个表达式为真则结果为真，此时跳过第二个表达式；</p><p>​    作用： </p><p>1、由于&amp;&amp;和||的表达式存在短路运算现象，在短路之后不会对后面的表达式进行运算，所以含有&amp;&amp;和||的表达式最好不要进行变量的赋值和运算操作，可以先计算好每个表达式的结果，直接拿结果进行&amp;&amp;和||的运算<br>2、在代码编写的时候就要注意这一点，以防由于&amp;&amp;和||的短路运算导致写出来的代码运算结果与预期的不同<br>3、把能快速确定整个表达式结果true或false的表达式放在前面，这样由于短路运算后面的表达式可能不会被运算到，节省处理器的运算时间</p><p>相关代码：</p><pre><code class="java">/** * @Author: YoYopupunsi * @Description: * @Date: Created in 13:17 2021/2/3 0003 * @Modified By: */import java.util.Scanner;public class LogicalOperators &#123;    public static void main(String [] args)&#123;        // 1.声明两个boolean类型的变量并初始化        boolean b1 = true;        boolean b2 = false;        // 2.打印变量的数值        System.out.println(&quot;b1 = &quot; + b1); // b1 = true        System.out.println(&quot;b2 = &quot; + b2); // b2 = false        // 3.使用上述变量实现逻辑运算符的使用        boolean b3 = b1 &amp;&amp; b2;        System.out.println(&quot;b3 = &quot; + b3); // false        System.out.println(b1 &amp;&amp; b2); // false   并且        System.out.println(b1 || b2); // true    或者        System.out.println(!b1);  // false       取反        System.out.println(!b2);  // true        // 4.测试一下短路特性        int ia = 3;        int ib = 5;        // 对于逻辑与运算符来说，若第一个条件为假则整个表达式为假，此时跳过第二个表达式不执行        boolean b4 = (++ia == 3) &amp;&amp; (++ib == 5);        System.out.println(&quot;b4 = &quot; + b4); // false        System.out.println(&quot;ia = &quot; + ia); // 4        System.out.println(&quot;ib = &quot; + ib); // 5        // 对于逻辑或运算符来说，若第一个条件为真则整个表达式为真，此时跳过第二个表达式不执行        boolean b5 = (++ia == 5) || (++ib == 5);        System.out.println(&quot;b5 = &quot; + b5); // true        System.out.println(&quot;ia = &quot; + ia); // 5        System.out.println(&quot;ib = &quot; + ib); // 5        // 1.提示用户输入一个正整数并使用变量记录        System.out.println(&quot;请输入一个正整数：&quot;);        Scanner sc = new Scanner(System.in);        int num = sc.nextInt();        // 2.使用逻辑运算符判断是否为三位数并打印    &gt;= 100   &lt;= 999   &amp;&amp;        //System.out.println(100 &lt;= num &lt;= 999); // 错误: 二元运算符 &#39;&lt;=&#39; 的操作数类型错误        // 逻辑运算符主要用于连接多个关系运算符作为最终运算的表达式，用于实现多条件的连接        System.out.println(100 &lt;= num &amp;&amp; num &lt;= 999);        // 使用三目运算符来判断是否为三位数        System.out.println(num + ((100 &lt;= num &amp;&amp; num &lt;= 999)? &quot;是三位数&quot;: &quot;不是三位数&quot;));    &#125;&#125;</code></pre><h4 id="六、条件-三目运算符"><a href="#六、条件-三目运算符" class="headerlink" title="六、条件/三目运算符"></a>六、条件/三目运算符</h4><p>条件表达式? 表达式1: 表达式2<br>格式：a&gt;b ? a:b；<br>判断条件表达式是否成立，若成立则执行表达式1，否则执行表达式2 </p><p>相关代码：</p><pre><code class="java">import java.util.Scanner;public class TernaryOperator &#123;    public static void main(String[] args) &#123;        // 1.提示用户分別输入两个整数并使用变量记录        System.out.println(&quot;请输入第一个整数：&quot;);        Scanner sc1 = new Scanner(System.in);        int i = sc1.nextInt();        System.out.println(&quot;请输入第二个整数：&quot;);        Scanner sc2 = new Scanner(System.in);        int j = sc2.nextInt();        // 2.使用三目运算符找到最大值并打印        int maxiMum = i &gt; j ? i : j;        System.out.println(&quot;最大值是：&quot; + maxiMum);        System.out.println(&quot;最大值是：&quot; + (i &gt; j? i : j));    &#125;&#125;</code></pre><h4 id="七、赋值运算符"><a href="#七、赋值运算符" class="headerlink" title="七、赋值运算符"></a>七、赋值运算符</h4><p>符号：=<br>1.当“=”两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理<br>2.支持连续赋值<br>赋值表达式本身也有值，其本身之值即为所赋之值</p><pre><code class="java">/** * @Author: YoYopupunsi * @Description: * @Date: Created in 15:26 2021/2/3 0003 * @Modified By: */public class AssignmentOperators &#123;    public static void main(String[] args) &#123;        // 1.声明一个int类型的变量并初始化        int i = 3;        // 2.打印变量的数值        System.out.println(&quot;i = &quot; + i); // i = 3        // 3.简单赋值运算符的使用        // 表示将数据5赋值给变量ia并且覆盖变量ia原来的数值        i = 5;        // 下面的代码是在打印表达式的结果        System.out.println( i = 5 ); // 5        System.out.println(&quot;i = &quot; + i); // i = 5        int j = i = 6;        System.out.println(&quot;i = &quot; + i); // i = 6        System.out.println(&quot;j = &quot; + j); // j = 6        int k;        k = j = i = 8;        System.out.println(&quot;i = &quot; + i); // i = 8        System.out.println(&quot;j = &quot; + j); // j = 8        System.out.println(&quot;k = &quot; + k); // k = 8        // 4.复合赋值运算符的使用        //i = i + 2;  目前推荐使用该方式        i += 2;        // 简化写法，从结果上来看是等价的        System.out.println(&quot;i = &quot; + i); // i = 10        // 5.笔试考点1        byte l = 10;        System.out.println(&quot;l = &quot; + l); // l = 10        //l = l + 2; // 错误: 不兼容的类型: 从int转换到byte可能会有损失         byte + int 相加结果还是int类型        //l = l + (byte)2; // 错误: 不兼容的类型: 从int转换到byte可能会有损失   byte + byte 相加结果还是int类型  编译器优化        //l = (byte)(l + 2); // 强制类型转换，将int类型转换为byte        l += 2; // 真正等价于l = (byte)(l + 2);        System.out.println(&quot;l = &quot; + l); // l = 12        l -= 2;        System.out.println(&quot;l-=2= &quot; + l);//l=10        l *= 2;        System.out.println(&quot;l*=2= &quot; + l);//20        l /= 2;        System.out.println(&quot;l/=2= &quot; + l);//10        l %= 2;        System.out.println(&quot;l%=2= &quot; + l);//0        // 6.笔试考点2        int a = 1;        boolean b = a == 1; //a==1; 表示判断变量b的数值是否等于1        System.out.println(b);//ture        System.out.println(a == 1);//ture        boolean b1 = 1 == a;//1 == a; 表示判断1是否等于变量a的数值，从结果上来说等价，推荐该方式        System.out.println(b1);//ture        System.out.println(1 == a);//ture        System.out.println(a = 1);//a = 1;   表示将1赋值给变量a，覆盖变量a原来的数值       //System.out.println(1 = a);//1 = a;  //- 编译报错  错误: 意外的类型  需要: 变量  找到:    值    &#125;&#125;</code></pre><h4 id="八、移位运算符"><a href="#八、移位运算符" class="headerlink" title="八、移位运算符"></a>八、移位运算符</h4><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143222.jpg?raw=true" alt="移位运算符"></p><pre><code class="java">public class MoveBitTest &#123;        public static void main(String[] args) &#123;                // 1.声明一个byte类型的变量并初始化        byte b1 = 13;        // 2.打印变量的数值        System.out.println(&quot;b1 = &quot; + b1); // b1 = 13                System.out.println(&quot;---------------------------------------------------&quot;);        // 3.移位运算符的使用        // 13的二进制是：... 0000 1101  =&gt; 左移1位的结果是：... 0001 1010 =&gt; 换算为十进制整数是：26        //byte b2 = b1 &lt;&lt; 1; // 错误: 不兼容的类型: 从int转换到byte可能会有损失   自动提升为int类型，也就是32位二进制        byte b2 = (byte)(b1 &lt;&lt; 1);         System.out.println(&quot;b2 = &quot; + b2); // 26        System.out.println(b1 &lt;&lt; 1); // 26    左移1位相当于当前整数的数值*2        System.out.println(b1 &lt;&lt; 2); // 52    左移2位相当于当前整数的数值*4                System.out.println(&quot;---------------------------------------------------&quot;);        // 13的二进制是：... 0000 1101 =&gt; 右移1位的结果是：... 0000 0110 =&gt; 换算为十进制整数是：6        System.out.println(b1 &gt;&gt; 1); // 6     右移1位相当于当前整数的数值/2        System.out.println(b1 &gt;&gt; 2); // 3     右移2位相当于当前整数的数值/4                System.out.println(&quot;---------------------------------------------------&quot;);        // 逻辑右移   对于非负数来说，逻辑右移和右移的效果一致        System.out.println(b1 &gt;&gt;&gt; 2); // 3      &#125;&#125;</code></pre><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143848.png?raw=true"></p><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143849.png?raw=true"></p><h4 id="九、位运算符"><a href="#九、位运算符" class="headerlink" title="九、位运算符"></a>九、位运算符</h4><ul><li>&amp; 表示按位与运算符，按照二进制位进行与运算，同1为1，一0为0.</li><li>| 表示按位或运算符，按照二进制位进行或运算，一1为1，同0为0.</li><li>~ 表示按位取反运算符，按照二进制位进行取反，1为0，0为1.</li><li>^ 表示按位异或运算符，按照二进制位进行异或运算，同为0，不同为1.</li><li>相关代码：</li></ul><pre><code class="java">public class BitTest &#123;        public static void main(String[] args) &#123;                // 1.声明两个byte类型的变量并初始化        byte b1 = 11;        byte b2 = 13;        // 2.打印变量的数值        System.out.println(&quot;b1 = &quot; + b1); // b1 = 11        System.out.println(&quot;b2 = &quot; + b2); // b2 = 13                System.out.println(&quot;---------------------------------------------------&quot;);        // 3.实现位运算符的使用        // b1的二进制为： 0000 1011                  // b2的二进制为： 0000 1101        System.out.println( b1 &amp; b2);  // 按位与：同1为1，一0为0      按位与后的二进制为：0000 1001  =&gt; 转为十进制是：9        System.out.println( b1 | b2);  // 按位或：一1为1，同0为0      按位或后的二进制为：0000 1111  =&gt; 转为十进制是：15        System.out.println( b1 ^ b2);  // 按位异或：相同为0，不同为1  按位异或的二进制为：0000 0110  =&gt; 转为十进制是：6        System.out.println( ~ b1);     // 按位取反：1为0,0为1         按位取反的二进制为：1111 0100         // 二进制1111 0100转为十进制 =&gt; 先减1: 1111 0011 =&gt; 按位取反：0000 1100 =&gt; 转为十进制：12  =&gt; 添加负号：-12    &#125;&#125;</code></pre><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143845.png?raw=true"></p><h4 id="十、运算符的优先级"><a href="#十、运算符的优先级" class="headerlink" title="十、运算符的优先级"></a>十、运算符的优先级</h4><ul><li>()的优先级极高 </li><li>=的优先级极低</li><li>若无法确认优先级，则使用()来确保即可</li></ul><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143846.png?raw=true"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机语言的概述 </tag>
            
            <tag> 变量及数据类型 </tag>
            
            <tag> 运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客搭建</title>
      <link href="posts/e3e08109.html"/>
      <url>posts/e3e08109.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 博客篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
