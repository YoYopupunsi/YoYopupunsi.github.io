<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="posts/undefined.html"/>
      <url>posts/undefined.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="posts/undefined.html"/>
      <url>posts/undefined.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>牛客面试题-Java工程师</title>
      <link href="posts/86sjk55a.html"/>
      <url>posts/86sjk55a.html</url>
      
        <content type="html"><![CDATA[<p>每日一练：</p><p>1.定义类中成员变量时不可能用到的修饰是<strong>（B）</strong></p><p><code>A.final</code></p><p><code>B.void</code></p><p><code>C.protected</code></p><p><code>D.static</code></p><p>解析：void修饰的是成员方法，不能修饰成员变量，没有返回值，final是修饰常量的，protected是保护的，static是静态的</p><p>2.已知表达式int m[]={0，1，2，3，4，5，6}；下面哪个表达式的值与数组下标量最大值相等？<strong>（B）</strong></p><pre><code class="java">A  m. length()B  m. length-1C  m. length()+1D  m. length+1</code></pre><p>解析：B      </p><p>m的下标是从0开始的</p><p>length — arrays (int[], double[], String[]) —- to know the length of the arrays</p><p>length() — String related Object (String, StringBuilder etc)to know the length of the String </p><p>size() — Collection Object (ArrayList, Set etc)to know the size of the Collection</p><p>3.判断对错。List，Set，Map都继承自继承Collection接口。**(B)**</p><p><code>A.对</code></p><p><code>B.错</code></p><p>解析：B</p><p>List，Set等集合对象都继承自Collection接口</p><p>Map是一个顶层结果，不继承自Collection接口</p><p>Collection接口：</p><p>1、List接口：内容允许重复</p><p>1.1、ArrayList</p><p>1.2、LinkedList，也实现了Queue接口</p><p>1.3、Vector</p><p>2、Set接口：内容不允许重复</p><p>3、Queue接口：队列接口</p><p>4、sortedSet接口：单值排序接口</p><p>Map接口：</p><p>1、HashMap：无序存放，key不重复</p><p>2、HashTable接口：无序存放，key不重复</p><p>3、TreeMap接口：按key排序，key不重复</p><p>4、IdentityHashMap接口:key可重复</p><p>5、WeakHashMap接口：弱引Map集合</p><p>4.下列程序执行后输出结果为<strong>（D）</strong></p><pre><code class="java">class BaseClass &#123; public BaseClass() &#123;&#125; &#123; System.out.println(&quot;I’m BaseClass class&quot;); &#125; static &#123; System.out.println(&quot;static BaseClass&quot;); &#125; &#125; public class Base extends BaseClass &#123; public Base() &#123;&#125; &#123; System.out.println(&quot;I’m Base class&quot;); &#125; static &#123; System.out.println(&quot;static Base&quot;); &#125; public static void main(String[] args) &#123; new Base(); &#125; &#125;</code></pre><pre><code class="java">Astatic BaseClassI’m BaseClass classstatic BaseI’m Base classBI’m BaseClass classI’m Base classstatic BaseClassstatic BaseCI’m BaseClass classstatic BaseClassI’m Base classstatic BaseDstatic BaseClassstatic BaseI’m BaseClass classI’m Base class</code></pre><p>解析：D</p><p>补充一下完整版的，执行顺序从左到右：</p><p>父类静态代码块 -&gt;子类静态代码块 -&gt;父类非静态代码块 -&gt; 父类构造函数 -&gt; 子类非静态代码块 -&gt; 子类构造函数。</p><pre><code class="java">public class Father &#123;  static &#123;        System.out.println(&quot;父类静态代码块&quot;);    &#125;    &#123;        System.out.println(&quot;父类非静态代码块&quot;);    &#125;  public Father()&#123;        System.out.println(&quot;父类构造函数&quot;);    &#125;   &#125;public class Son extends Father&#123;  static &#123;        System.out.println(&quot;子类静态代码块&quot;);    &#125;    &#123;        System.out.println(&quot;子类非静态代码块&quot;);    &#125;  public Son()&#123;        System.out.println(&quot;子类构造函数&quot;);    &#125;  public static void main(String[] args) &#123;        Son son = new Son();    &#125;&#125;结果为：   父类静态代码块    子类静态代码块    父类非静态代码块    父类构造函数    子类非静态代码块    子类构造函数 </code></pre><p>5.如果一个接口Glass有个方法setColor()，有个类BlueGlass实现接口Glass，则在类BlueGlass中正确的是？  <strong>( C)</strong></p><pre><code class="java">A   protected void setColor() &#123; …&#125;B   void setColor() &#123; …&#125;C   public void setColor() &#123; …&#125;D   以上语句都可以用在类BlueGlass中</code></pre><p>解析：C</p><pre><code class="java">JAVA 子类重写继承的方法时,不可以降低方法的访问权限，子类继承父类的访问修饰符要比父类的更大，也就是更加开放，假如我父类是protected修饰的，其子类只能是protected或者public，绝对不能是friendly(默认的访问范围)或者private，当然使用private就不是继承了。还要注意的是，继承当中子类抛出的异常必须是父类抛出的异常的子异常，或者子类抛出的异常要比父类抛出的异常要少。接口中属性为public static final。方法为public abstract。子类的权限不能比父类更低</code></pre>]]></content>
      
      
      <categories>
          
          <category> 牛客-java面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛客 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode算法-数组和字符串</title>
      <link href="posts/78ds5we6.html"/>
      <url>posts/78ds5we6.html</url>
      
        <content type="html"><![CDATA[<h3 id="LC寻找数组的中心索引"><a href="#LC寻找数组的中心索引" class="headerlink" title="LC寻找数组的中心索引"></a>LC寻找数组的中心索引</h3><p>给你一个整数数组 nums，请编写一个能够返回数组 “中心索引” 的方法。</p><p>数组 中心索引 是数组的一个索引，其左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果数组不存在中心索引，返回 -1 。如果数组有多个中心索引，应该返回最靠近左边的那一个。</p><p>注意：中心索引可能出现在数组的两端。</p><p>示例 1：</p><p><code>输入：nums = [1, 7, 3, 6, 5, 6] 输出：3 解释： 中心索引是 3 。 左侧数之和 (1 + 7 + 3 = 11)， 右侧数之和 (5 + 6 = 11) ，二者相等。</code></p><p>示例 2：</p><p><code>输入：nums = [1, 2, 3]</code><br><code>输出：-1</code><br><code>解释：</code><br><code>数组中不存在满足此条件的中心索引。</code><br>示例 3：</p><p><code>输入：nums = [2, 1, -1]</code><br><code>输出：0</code><br><code>解释：</code><br><code>中心索引是 0 。</code><br><code>索引 0 左侧不存在元素，视作和为 0 ；</code><br><code>右侧数之和为 1 + (-1) = 0 ，二者相等。</code></p><p>提示：</p><p><code>nums 的长度范围为 [0, 10000]。</code><br><code>任何一个 nums[i] 将会是一个范围在 [-1000, 1000]的整数。</code></p><p>解题思路：</p><p>当时的思路是这样的，算出来所有数的和，然后指针索引从左边向右边移动，看一下左边和是不是等于右边的和，如果相等就返回这个指针索引的位置，否则找不到就返回-1。</p><p>现在整理的时候又有了两个新思路。</p><p>思路1：</p><p>算出所有数的总和之后，直接从左边开始加什么时候等于总和的一半为止，如果没找到就返回-1；</p><p>思路2：</p><p>双指针索引方法，一个从左边开始加，一个从右边开始加，如果左边和大于右边和就右边指针索引向左移动一下，否则左边移动一下，直到两个指针相遇了，判断两边和相等不，如果相等就返回这个位置，如果不等就返回-1。但是有个细节要注意，就是有多个中心索引的情况，因此不能两边相等就停止，而应该是两指针相遇的时候才停止，并且右边的指针再相等的情况下应该优先动，这样才能保证是最左边的中心索引。</p><p>代码实现：</p><pre><code class="java">class Solution &#123;    public int pivotIndex(int[] nums) &#123;        if(nums.length &lt; 2)            return -1;        int leftSum = 0;        int rightSum = 0;        int sum = 0;        for(int n:nums)&#123;            sum += n;        &#125;        System.out.println(sum);        int i;        for(i=0;i&lt;nums.length;i++)&#123;            if(i==0)                leftSum = 0;            else                leftSum += nums[i-1];            rightSum = sum - leftSum - nums[i];            if(leftSum == rightSum)                return i;        &#125;        System.out.println(i);        return -1;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode算法-数组和字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数组和字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWEB核心MVC模式&amp;三层架构</title>
      <link href="posts/u88qsw8t.html"/>
      <url>posts/u88qsw8t.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、MVC模式概述"><a href="#一、MVC模式概述" class="headerlink" title="一、MVC模式概述"></a>一、MVC模式概述</h3><h3 id="二、MVC处理流程"><a href="#二、MVC处理流程" class="headerlink" title="二、MVC处理流程"></a>二、MVC处理流程</h3><h3 id="三、三层架构概述"><a href="#三、三层架构概述" class="headerlink" title="三、三层架构概述"></a>三、三层架构概述</h3><h3 id="四、三层架构之控制层"><a href="#四、三层架构之控制层" class="headerlink" title="四、三层架构之控制层"></a>四、三层架构之控制层</h3><h3 id="五、三层架构之业务层"><a href="#五、三层架构之业务层" class="headerlink" title="五、三层架构之业务层"></a>五、三层架构之业务层</h3><h3 id="六、三层架构之数据访问层"><a href="#六、三层架构之数据访问层" class="headerlink" title="六、三层架构之数据访问层"></a>六、三层架构之数据访问层</h3>]]></content>
      
      
      <categories>
          
          <category> JavaWEB核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MVC模式 </tag>
            
            <tag> 三层架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWEB核心Filter&amp;Listener</title>
      <link href="posts/u99qsw8t.html"/>
      <url>posts/u99qsw8t.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、Filter原理"><a href="#一、Filter原理" class="headerlink" title="一、Filter原理"></a>一、Filter原理</h3><h3 id="二、Filter声明周期"><a href="#二、Filter声明周期" class="headerlink" title="二、Filter声明周期"></a>二、Filter声明周期</h3><h3 id="三、Filter链"><a href="#三、Filter链" class="headerlink" title="三、Filter链"></a>三、Filter链</h3><h3 id="四、Filter登录验证"><a href="#四、Filter登录验证" class="headerlink" title="四、Filter登录验证"></a>四、Filter登录验证</h3><h3 id="五、Filter事务控制"><a href="#五、Filter事务控制" class="headerlink" title="五、Filter事务控制"></a>五、Filter事务控制</h3><h3 id="六、Listener原理"><a href="#六、Listener原理" class="headerlink" title="六、Listener原理"></a>六、Listener原理</h3><h3 id="七、八大监听器使用"><a href="#七、八大监听器使用" class="headerlink" title="七、八大监听器使用"></a>七、八大监听器使用</h3><h3 id="八、Listener监听在线用户"><a href="#八、Listener监听在线用户" class="headerlink" title="八、Listener监听在线用户"></a>八、Listener监听在线用户</h3>]]></content>
      
      
      <categories>
          
          <category> JavaWEB核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Filter </tag>
            
            <tag> Listener </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWEB核心Cookie&amp;Session</title>
      <link href="posts/up7qsw8t.html"/>
      <url>posts/up7qsw8t.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、Cookie机制"><a href="#一、Cookie机制" class="headerlink" title="一、Cookie机制"></a>一、Cookie机制</h3><h3 id="二、Cookie创建-amp-使用"><a href="#二、Cookie创建-amp-使用" class="headerlink" title="二、Cookie创建&amp;使用"></a>二、Cookie创建&amp;使用</h3><h3 id="三、Session原理"><a href="#三、Session原理" class="headerlink" title="三、Session原理"></a>三、Session原理</h3><h3 id="四、Session失效"><a href="#四、Session失效" class="headerlink" title="四、Session失效"></a>四、Session失效</h3><h3 id="五、URL重写"><a href="#五、URL重写" class="headerlink" title="五、URL重写"></a>五、URL重写</h3><h3 id="六、Session活化-amp-钝化"><a href="#六、Session活化-amp-钝化" class="headerlink" title="六、Session活化&amp;钝化"></a>六、Session活化&amp;钝化</h3><h3 id="七、Token令牌应用"><a href="#七、Token令牌应用" class="headerlink" title="七、Token令牌应用"></a>七、Token令牌应用</h3>]]></content>
      
      
      <categories>
          
          <category> JavaWEB核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cookie </tag>
            
            <tag> Session </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWEB核心Jsp</title>
      <link href="posts/up7qsw9t.html"/>
      <url>posts/up7qsw9t.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、JSP语法"><a href="#一、JSP语法" class="headerlink" title="一、JSP语法"></a>一、JSP语法</h3><h3 id="二、JSP原理"><a href="#二、JSP原理" class="headerlink" title="二、JSP原理"></a>二、JSP原理</h3><h3 id="三、JSP脚本片段-amp-表达式"><a href="#三、JSP脚本片段-amp-表达式" class="headerlink" title="三、JSP脚本片段&amp;表达式"></a>三、JSP脚本片段&amp;表达式</h3><h3 id="四、JSP声明-amp-amp；指令"><a href="#四、JSP声明-amp-amp；指令" class="headerlink" title="四、JSP声明&amp;amp；指令"></a>四、JSP声明&amp;amp；指令</h3><h3 id="五、JSP九大隐含对象"><a href="#五、JSP九大隐含对象" class="headerlink" title="五、JSP九大隐含对象"></a>五、JSP九大隐含对象</h3><h3 id="六、域对象使用"><a href="#六、域对象使用" class="headerlink" title="六、域对象使用"></a>六、域对象使用</h3><h3 id="七、EL表达式"><a href="#七、EL表达式" class="headerlink" title="七、EL表达式"></a>七、EL表达式</h3><h4 id="7-1、EL表达式简介"><a href="#7-1、EL表达式简介" class="headerlink" title="7.1、EL表达式简介"></a>7.1、EL表达式简介</h4><h4 id="7-2、EL使用"><a href="#7-2、EL使用" class="headerlink" title="7.2、EL使用"></a>7.2、EL使用</h4><h4 id="7-3、EL取值原理"><a href="#7-3、EL取值原理" class="headerlink" title="7.3、EL取值原理"></a>7.3、EL取值原理</h4><h4 id="7-4、EL的11大隐含对象"><a href="#7-4、EL的11大隐含对象" class="headerlink" title="7.4、EL的11大隐含对象"></a>7.4、EL的11大隐含对象</h4><h4 id="7-5、EL2-2与3-0规范"><a href="#7-5、EL2-2与3-0规范" class="headerlink" title="7.5、EL2.2与3.0规范"></a>7.5、EL2.2与3.0规范</h4><h4 id="7-6、EL逻辑运算"><a href="#7-6、EL逻辑运算" class="headerlink" title="7.6、EL逻辑运算"></a>7.6、EL逻辑运算</h4><h4 id="7-7、函数库深入"><a href="#7-7、函数库深入" class="headerlink" title="7.7、函数库深入"></a>7.7、函数库深入</h4><h3 id="八、JSTL"><a href="#八、JSTL" class="headerlink" title="八、JSTL"></a>八、JSTL</h3><h4 id="8-1、JSTL简介"><a href="#8-1、JSTL简介" class="headerlink" title="8.1、JSTL简介"></a>8.1、JSTL简介</h4><h4 id="8-2、JSTL-核心标签库"><a href="#8-2、JSTL-核心标签库" class="headerlink" title="8.2、JSTL-核心标签库"></a>8.2、JSTL-核心标签库</h4><h4 id="8-3、JSTL-函数标签库"><a href="#8-3、JSTL-函数标签库" class="headerlink" title="8.3、JSTL-函数标签库"></a>8.3、JSTL-函数标签库</h4><h4 id="8-4、JSTL-fmt标签库"><a href="#8-4、JSTL-fmt标签库" class="headerlink" title="8.4、JSTL-fmt标签库"></a>8.4、JSTL-fmt标签库</h4><h4 id="8-5、自定义标签库使用"><a href="#8-5、自定义标签库使用" class="headerlink" title="8.5、自定义标签库使用"></a>8.5、自定义标签库使用</h4><h4 id="8-6、自定义标签库原理"><a href="#8-6、自定义标签库原理" class="headerlink" title="8.6、自定义标签库原理"></a>8.6、自定义标签库原理</h4>]]></content>
      
      
      <categories>
          
          <category> JavaWEB核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jsp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWEB核心Servlet</title>
      <link href="posts/up7qsw9t.html"/>
      <url>posts/up7qsw9t.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、Servlet体系"><a href="#一、Servlet体系" class="headerlink" title="一、Servlet体系"></a>一、Servlet体系</h3><h3 id="二、Servlet生命周期"><a href="#二、Servlet生命周期" class="headerlink" title="二、Servlet生命周期"></a>二、Servlet生命周期</h3><h3 id="三、ServletConfig-amp-ServletContext"><a href="#三、ServletConfig-amp-ServletContext" class="headerlink" title="三、ServletConfig&amp;ServletContext"></a>三、ServletConfig&amp;ServletContext</h3><h3 id="四、请求-amp-amp；响应"><a href="#四、请求-amp-amp；响应" class="headerlink" title="四、请求&amp;amp；响应"></a>四、请求&amp;amp；响应</h3><h3 id="五、重定向-amp-amp；转发"><a href="#五、重定向-amp-amp；转发" class="headerlink" title="五、重定向&amp;amp；转发"></a>五、重定向&amp;amp；转发</h3><h3 id="六、中文乱码解决方案"><a href="#六、中文乱码解决方案" class="headerlink" title="六、中文乱码解决方案"></a>六、中文乱码解决方案</h3><h3 id="七、项目路径问题"><a href="#七、项目路径问题" class="headerlink" title="七、项目路径问题"></a>七、项目路径问题</h3><h3 id="八、Request"><a href="#八、Request" class="headerlink" title="八、Request"></a>八、Request</h3><h3 id="九、Response"><a href="#九、Response" class="headerlink" title="九、Response"></a>九、Response</h3>]]></content>
      
      
      <categories>
          
          <category> JavaWEB核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWEB核心Tomcat</title>
      <link href="posts/ui7qsw9t.html"/>
      <url>posts/ui7qsw9t.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、HTTP协议"><a href="#一、HTTP协议" class="headerlink" title="一、HTTP协议"></a>一、HTTP协议</h3><h3 id="二、HttpWatch"><a href="#二、HttpWatch" class="headerlink" title="二、HttpWatch"></a>二、HttpWatch</h3><h3 id="三、Tomcat服务器搭建"><a href="#三、Tomcat服务器搭建" class="headerlink" title="三、Tomcat服务器搭建"></a>三、Tomcat服务器搭建</h3><h3 id="四、Tomcat目录结构解析"><a href="#四、Tomcat目录结构解析" class="headerlink" title="四、Tomcat目录结构解析"></a>四、Tomcat目录结构解析</h3><h3 id="五、Tomcat端口配置"><a href="#五、Tomcat端口配置" class="headerlink" title="五、Tomcat端口配置"></a>五、Tomcat端口配置</h3><h3 id="六、Tomcat启动-amp-停止"><a href="#六、Tomcat启动-amp-停止" class="headerlink" title="六、Tomcat启动&amp;停止"></a>六、Tomcat启动&amp;停止</h3><h3 id="七、Tomcat-amp-Idea整合"><a href="#七、Tomcat-amp-Idea整合" class="headerlink" title="七、Tomcat&amp;Idea整合"></a>七、Tomcat&amp;Idea整合</h3>]]></content>
      
      
      <categories>
          
          <category> JavaWEB核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端技术ES6</title>
      <link href="posts/mm5f6ss3.html"/>
      <url>posts/mm5f6ss3.html</url>
      
        <content type="html"><![CDATA[<p>一、前端开发工程师、ES6简介</p><p>二、ES6基础语法：let、const</p><p>三、ES6基础语法：解构赋值、模板字符串</p><p>四、ES6基础语法：声明对象、方法简写</p><p>五、ES6基础语法：对象拓展运算符、函数默认参数、不定参数、箭头函数</p><p>六、ES6基础语法：Promise</p><p>七、ES6模块化</p><p>八、总结</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端技术jQuery</title>
      <link href="posts/ty5f6ss3.html"/>
      <url>posts/ty5f6ss3.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、jQuery快速入门"><a href="#一、jQuery快速入门" class="headerlink" title="一、jQuery快速入门"></a>一、jQuery快速入门</h3><h3 id="二、jQuery语法详解"><a href="#二、jQuery语法详解" class="headerlink" title="二、jQuery语法详解"></a>二、jQuery语法详解</h3><h3 id="三、jQuery核心函数"><a href="#三、jQuery核心函数" class="headerlink" title="三、jQuery核心函数"></a>三、jQuery核心函数</h3><h3 id="四、jQuery对象-JavaScript对象"><a href="#四、jQuery对象-JavaScript对象" class="headerlink" title="四、jQuery对象/JavaScript对象"></a>四、jQuery对象/JavaScript对象</h3><h3 id="五、jQuery选择器"><a href="#五、jQuery选择器" class="headerlink" title="五、jQuery选择器"></a>五、jQuery选择器</h3><h3 id="六、jQuery文档处理"><a href="#六、jQuery文档处理" class="headerlink" title="六、jQuery文档处理"></a>六、jQuery文档处理</h3><h3 id="七、jQuery事件"><a href="#七、jQuery事件" class="headerlink" title="七、jQuery事件"></a>七、jQuery事件</h3><h3 id="八、jQuery动画效果"><a href="#八、jQuery动画效果" class="headerlink" title="八、jQuery动画效果"></a>八、jQuery动画效果</h3>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端技术JavaScript</title>
      <link href="posts/qo5f6dd3.html"/>
      <url>posts/qo5f6dd3.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、JavaScript基本语法"><a href="#一、JavaScript基本语法" class="headerlink" title="一、JavaScript基本语法"></a>一、JavaScript基本语法</h3><h3 id="二、JavaScript流程控制"><a href="#二、JavaScript流程控制" class="headerlink" title="二、JavaScript流程控制"></a>二、JavaScript流程控制</h3><h3 id="三、数组、函数、对象的使用"><a href="#三、数组、函数、对象的使用" class="headerlink" title="三、数组、函数、对象的使用"></a>三、数组、函数、对象的使用</h3><h3 id="四、JavaScript事件绑定-触发"><a href="#四、JavaScript事件绑定-触发" class="headerlink" title="四、JavaScript事件绑定/触发"></a>四、JavaScript事件绑定/触发</h3><h3 id="五、JavaScript事件冒泡"><a href="#五、JavaScript事件冒泡" class="headerlink" title="五、JavaScript事件冒泡"></a>五、JavaScript事件冒泡</h3><h3 id="六、JavaScript嵌入方式"><a href="#六、JavaScript嵌入方式" class="headerlink" title="六、JavaScript嵌入方式"></a>六、JavaScript嵌入方式</h3><h3 id="七、JavaScript-DOM操作"><a href="#七、JavaScript-DOM操作" class="headerlink" title="七、JavaScript DOM操作"></a>七、JavaScript DOM操作</h3><h3 id="八、DOM-API"><a href="#八、DOM-API" class="headerlink" title="八、DOM API"></a>八、DOM API</h3>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端技术CSS</title>
      <link href="posts/wo5f6dd3.html"/>
      <url>posts/wo5f6dd3.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、CSS选择器"><a href="#一、CSS选择器" class="headerlink" title="一、CSS选择器"></a>一、CSS选择器</h3><h3 id="二、常用样式"><a href="#二、常用样式" class="headerlink" title="二、常用样式"></a>二、常用样式</h3><h3 id="三、盒子模型与布局"><a href="#三、盒子模型与布局" class="headerlink" title="三、盒子模型与布局"></a>三、盒子模型与布局</h3><h3 id="四、HTML5新特性"><a href="#四、HTML5新特性" class="headerlink" title="四、HTML5新特性"></a>四、HTML5新特性</h3><h3 id="五、CSS3新特性"><a href="#五、CSS3新特性" class="headerlink" title="五、CSS3新特性"></a>五、CSS3新特性</h3>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端技术HTML</title>
      <link href="posts/wo9f7ss3.html"/>
      <url>posts/wo9f7ss3.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、B-S架构"><a href="#一、B-S架构" class="headerlink" title="一、B/S架构"></a>一、B/S架构</h3><h3 id="二、HTML基本使用"><a href="#二、HTML基本使用" class="headerlink" title="二、HTML基本使用"></a>二、HTML基本使用</h3><h3 id="三、HTML-DOM"><a href="#三、HTML-DOM" class="headerlink" title="三、HTML DOM"></a>三、HTML DOM</h3>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端技术XML</title>
      <link href="posts/wo5f6ss3.html"/>
      <url>posts/wo5f6ss3.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、XML用途"><a href="#一、XML用途" class="headerlink" title="一、XML用途"></a>一、XML用途</h3><h3 id="二、XML文档结构"><a href="#二、XML文档结构" class="headerlink" title="二、XML文档结构"></a>二、XML文档结构</h3><h3 id="三、XML基本语法"><a href="#三、XML基本语法" class="headerlink" title="三、XML基本语法"></a>三、XML基本语法</h3><h3 id="四、DOM-amp-SAX解析体系"><a href="#四、DOM-amp-SAX解析体系" class="headerlink" title="四、DOM&amp;SAX解析体系"></a>四、DOM&amp;SAX解析体系</h3><h3 id="五、DOM4j节点查询"><a href="#五、DOM4j节点查询" class="headerlink" title="五、DOM4j节点查询"></a>五、DOM4j节点查询</h3><h3 id="六、DOM4j文档操作"><a href="#六、DOM4j文档操作" class="headerlink" title="六、DOM4j文档操作"></a>六、DOM4j文档操作</h3><h3 id="七、xPath语法"><a href="#七、xPath语法" class="headerlink" title="七、xPath语法"></a>七、xPath语法</h3><h3 id="八、xPath快速查询"><a href="#八、xPath快速查询" class="headerlink" title="八、xPath快速查询"></a>八、xPath快速查询</h3>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库技术DBUtils</title>
      <link href="posts/46d46we6.html"/>
      <url>posts/46d46we6.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、使用QueryRunner"><a href="#一、使用QueryRunner" class="headerlink" title="一、使用QueryRunner"></a>一、使用QueryRunner</h3><h3 id="二、可插拔式结果集处理"><a href="#二、可插拔式结果集处理" class="headerlink" title="二、可插拔式结果集处理"></a>二、可插拔式结果集处理</h3><h3 id="三、批量处理"><a href="#三、批量处理" class="headerlink" title="三、批量处理"></a>三、批量处理</h3><h3 id="四、大数据结果集处理"><a href="#四、大数据结果集处理" class="headerlink" title="四、大数据结果集处理"></a>四、大数据结果集处理</h3><h3 id="五、自定义结果集处理"><a href="#五、自定义结果集处理" class="headerlink" title="五、自定义结果集处理"></a>五、自定义结果集处理</h3><h3 id="六、利用DBUtils编写通用DAO"><a href="#六、利用DBUtils编写通用DAO" class="headerlink" title="六、利用DBUtils编写通用DAO"></a>六、利用DBUtils编写通用DAO</h3>]]></content>
      
      
      <categories>
          
          <category> 数据库技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DBUtils </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库技术JDBC</title>
      <link href="posts/3ad66we6.html"/>
      <url>posts/3ad66we6.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、JDBC概述"><a href="#一、JDBC概述" class="headerlink" title="一、JDBC概述"></a>一、JDBC概述</h3><h3 id="二、获取数据库连接"><a href="#二、获取数据库连接" class="headerlink" title="二、获取数据库连接"></a>二、获取数据库连接</h3><h3 id="三、数据库连接池C3P0、DBCP、Druid"><a href="#三、数据库连接池C3P0、DBCP、Druid" class="headerlink" title="三、数据库连接池C3P0、DBCP、Druid"></a>三、数据库连接池C3P0、DBCP、Druid</h3><h3 id="四、使用JDBC完成数据库DML操作"><a href="#四、使用JDBC完成数据库DML操作" class="headerlink" title="四、使用JDBC完成数据库DML操作"></a>四、使用JDBC完成数据库DML操作</h3><h3 id="五、大数据的操作"><a href="#五、大数据的操作" class="headerlink" title="五、大数据的操作"></a>五、大数据的操作</h3><h3 id="六、批量处理与元数据"><a href="#六、批量处理与元数据" class="headerlink" title="六、批量处理与元数据"></a>六、批量处理与元数据</h3><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      
      
      <categories>
          
          <category> 数据库技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库技术SQL</title>
      <link href="posts/37ds7we7.html"/>
      <url>posts/37ds7we7.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、SQL语句的三种类型"><a href="#一、SQL语句的三种类型" class="headerlink" title="一、SQL语句的三种类型"></a>一、SQL语句的三种类型</h3><h3 id="二、DML、DDL、DCL"><a href="#二、DML、DDL、DCL" class="headerlink" title="二、DML、DDL、DCL"></a>二、DML、DDL、DCL</h3><h3 id="三、数据处理"><a href="#三、数据处理" class="headerlink" title="三、数据处理"></a>三、数据处理</h3><h3 id="四、子查询"><a href="#四、子查询" class="headerlink" title="四、子查询"></a>四、子查询</h3><h3 id="五、创建和管理表"><a href="#五、创建和管理表" class="headerlink" title="五、创建和管理表"></a>五、创建和管理表</h3><h3 id="六、约束与分页"><a href="#六、约束与分页" class="headerlink" title="六、约束与分页"></a>六、约束与分页</h3><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      
      
      <categories>
          
          <category> 数据库技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库技术MySQL</title>
      <link href="posts/36ds6we6.html"/>
      <url>posts/36ds6we6.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、Mysql的安装和使用"><a href="#一、Mysql的安装和使用" class="headerlink" title="一、Mysql的安装和使用"></a>一、Mysql的安装和使用</h3><h3 id="二、图解Mysql程序结构"><a href="#二、图解Mysql程序结构" class="headerlink" title="二、图解Mysql程序结构"></a>二、图解Mysql程序结构</h3><h3 id="三、Mysql服务器的配置"><a href="#三、Mysql服务器的配置" class="headerlink" title="三、Mysql服务器的配置"></a>三、Mysql服务器的配置</h3><h3 id="四、Mysql客户端使用"><a href="#四、Mysql客户端使用" class="headerlink" title="四、Mysql客户端使用"></a>四、Mysql客户端使用</h3><h3 id="五、用户权限管理"><a href="#五、用户权限管理" class="headerlink" title="五、用户权限管理"></a>五、用户权限管理</h3><h3 id="六、Mysql数据库的使用"><a href="#六、Mysql数据库的使用" class="headerlink" title="六、Mysql数据库的使用"></a>六、Mysql数据库的使用</h3>]]></content>
      
      
      <categories>
          
          <category> 数据库技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8_9_10_11新特性</title>
      <link href="posts/33ds4we7.html"/>
      <url>posts/33ds4we7.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、Java8新特性"><a href="#一、Java8新特性" class="headerlink" title="一、Java8新特性"></a>一、Java8新特性</h2><ul><li><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3></li><li><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3></li><li><h3 id="Java8核心函数式接口"><a href="#Java8核心函数式接口" class="headerlink" title="Java8核心函数式接口"></a>Java8核心函数式接口</h3></li><li><h3 id="Lambda表达式的参数传递"><a href="#Lambda表达式的参数传递" class="headerlink" title="Lambda表达式的参数传递"></a>Lambda表达式的参数传递</h3></li><li><h3 id="方法引用与构造器引用"><a href="#方法引用与构造器引用" class="headerlink" title="方法引用与构造器引用"></a>方法引用与构造器引用</h3></li><li><h3 id="强大的Stream-API"><a href="#强大的Stream-API" class="headerlink" title="强大的Stream API"></a>强大的Stream API</h3></li><li><h3 id="Stream操作的核心步骤"><a href="#Stream操作的核心步骤" class="headerlink" title="Stream操作的核心步骤"></a>Stream操作的核心步骤</h3></li><li><h3 id="惰性求值与内部迭代"><a href="#惰性求值与内部迭代" class="headerlink" title="惰性求值与内部迭代"></a>惰性求值与内部迭代</h3></li><li><h3 id="筛选与切片"><a href="#筛选与切片" class="headerlink" title="筛选与切片"></a>筛选与切片</h3></li><li><h3 id="映射与排序"><a href="#映射与排序" class="headerlink" title="映射与排序"></a>映射与排序</h3></li><li><h3 id="查找与匹配"><a href="#查找与匹配" class="headerlink" title="查找与匹配"></a>查找与匹配</h3></li><li><h3 id="归约与收集"><a href="#归约与收集" class="headerlink" title="归约与收集"></a>归约与收集</h3></li><li><h3 id="并行流与串行流"><a href="#并行流与串行流" class="headerlink" title="并行流与串行流"></a>并行流与串行流</h3></li><li><h3 id="Optional容器类"><a href="#Optional容器类" class="headerlink" title="Optional容器类"></a>Optional容器类</h3></li></ul><h2 id="二、Java9-10-11新特性"><a href="#二、Java9-10-11新特性" class="headerlink" title="二、Java9/10/11新特性"></a>二、Java9/10/11新特性</h2><ul><li><h3 id="模块化系统"><a href="#模块化系统" class="headerlink" title="模块化系统"></a>模块化系统</h3></li><li><h3 id="jShell命令"><a href="#jShell命令" class="headerlink" title="jShell命令"></a>jShell命令</h3></li><li><h3 id="接口的私有方法"><a href="#接口的私有方法" class="headerlink" title="接口的私有方法"></a>接口的私有方法</h3></li><li><h3 id="语法改进：try和钻石操作符"><a href="#语法改进：try和钻石操作符" class="headerlink" title="语法改进：try和钻石操作符"></a>语法改进：try和钻石操作符</h3></li><li><h3 id="String存储结构变更"><a href="#String存储结构变更" class="headerlink" title="String存储结构变更"></a>String存储结构变更</h3></li><li><h3 id="增强的Stream-API"><a href="#增强的Stream-API" class="headerlink" title="增强的Stream API"></a>增强的Stream API</h3></li><li><h3 id="全新的HTTP客户端API"><a href="#全新的HTTP客户端API" class="headerlink" title="全新的HTTP客户端API"></a>全新的HTTP客户端API</h3></li><li><h3 id="局部变量的类型判断"><a href="#局部变量的类型判断" class="headerlink" title="局部变量的类型判断"></a>局部变量的类型判断</h3></li><li><h3 id="集合新增一系列处理方法"><a href="#集合新增一系列处理方法" class="headerlink" title="集合新增一系列处理方法"></a>集合新增一系列处理方法</h3></li><li><h3 id="Optional加强"><a href="#Optional加强" class="headerlink" title="Optional加强"></a>Optional加强</h3></li><li><h3 id="更简化的编译运行程序"><a href="#更简化的编译运行程序" class="headerlink" title="更简化的编译运行程序"></a>更简化的编译运行程序</h3></li><li><h3 id="废弃Nashorm引擎"><a href="#废弃Nashorm引擎" class="headerlink" title="废弃Nashorm引擎"></a>废弃Nashorm引擎</h3></li><li><h3 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h3></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java8新特性 </tag>
            
            <tag> Java9/10/11新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java网络编程</title>
      <link href="posts/45ds5we6.html"/>
      <url>posts/45ds5we6.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、网络编程基础知识"><a href="#一、网络编程基础知识" class="headerlink" title="一、网络编程基础知识"></a>一、网络编程基础知识</h3><h3 id="二、网络编程的主要问题"><a href="#二、网络编程的主要问题" class="headerlink" title="二、网络编程的主要问题"></a>二、网络编程的主要问题</h3><h3 id="三、如何实现网络中主机的相互通讯"><a href="#三、如何实现网络中主机的相互通讯" class="headerlink" title="三、如何实现网络中主机的相互通讯"></a>三、如何实现网络中主机的相互通讯</h3><h3 id="四、网络通讯要素"><a href="#四、网络通讯要素" class="headerlink" title="四、网络通讯要素"></a>四、网络通讯要素</h3><h3 id="五、网络通信协议"><a href="#五、网络通信协议" class="headerlink" title="五、网络通信协议"></a>五、网络通信协议</h3><h3 id="六、OSI参考模型"><a href="#六、OSI参考模型" class="headerlink" title="六、OSI参考模型"></a>六、OSI参考模型</h3><h3 id="七、TCP-IP参考模型（或TCP-IP协议）"><a href="#七、TCP-IP参考模型（或TCP-IP协议）" class="headerlink" title="七、TCP/IP参考模型（或TCP/IP协议）"></a>七、TCP/IP参考模型（或TCP/IP协议）</h3><h3 id="八、数据的封装与拆封"><a href="#八、数据的封装与拆封" class="headerlink" title="八、数据的封装与拆封"></a>八、数据的封装与拆封</h3><h3 id="九、Java-net-InetAddress类"><a href="#九、Java-net-InetAddress类" class="headerlink" title="九、Java.net.InetAddress类"></a>九、Java.net.InetAddress类</h3><h3 id="十、TCP协议与UDP协议"><a href="#十、TCP协议与UDP协议" class="headerlink" title="十、TCP协议与UDP协议"></a>十、TCP协议与UDP协议</h3><h3 id="十一、基于TCP协议的网络编程"><a href="#十一、基于TCP协议的网络编程" class="headerlink" title="十一、基于TCP协议的网络编程"></a>十一、基于TCP协议的网络编程</h3><h3 id="十二、Socket的TCP编程"><a href="#十二、Socket的TCP编程" class="headerlink" title="十二、Socket的TCP编程"></a>十二、Socket的TCP编程</h3><h3 id="十三、基于UDP协议的网络编程"><a href="#十三、基于UDP协议的网络编程" class="headerlink" title="十三、基于UDP协议的网络编程"></a>十三、基于UDP协议的网络编程</h3><h3 id="十四、URL编程"><a href="#十四、URL编程" class="headerlink" title="十四、URL编程"></a>十四、URL编程</h3><h3 id="十五、针对HTTP协议的URLConnection"><a href="#十五、针对HTTP协议的URLConnection" class="headerlink" title="十五、针对HTTP协议的URLConnection"></a>十五、针对HTTP协议的URLConnection</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaReflection（Java反射）</title>
      <link href="posts/78ds5we6.html"/>
      <url>posts/78ds5we6.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、Java反射机制的研究与应用"><a href="#一、Java反射机制的研究与应用" class="headerlink" title="一、Java反射机制的研究与应用"></a>一、Java反射机制的研究与应用</h3><h3 id="二、反射的原理分析"><a href="#二、反射的原理分析" class="headerlink" title="二、反射的原理分析"></a>二、反射的原理分析</h3><h3 id="三、JVM与类"><a href="#三、JVM与类" class="headerlink" title="三、JVM与类"></a>三、JVM与类</h3><h3 id="四、类的加载、连接、初始化"><a href="#四、类的加载、连接、初始化" class="headerlink" title="四、类的加载、连接、初始化"></a>四、类的加载、连接、初始化</h3><h3 id="五、类初始化的时机"><a href="#五、类初始化的时机" class="headerlink" title="五、类初始化的时机"></a>五、类初始化的时机</h3><h3 id="六、类加载器ClassLoader简介"><a href="#六、类加载器ClassLoader简介" class="headerlink" title="六、类加载器ClassLoader简介"></a>六、类加载器ClassLoader简介</h3><h3 id="七、类加载机制"><a href="#七、类加载机制" class="headerlink" title="七、类加载机制"></a>七、类加载机制</h3><h3 id="八、创建并使用自定义的类加载器"><a href="#八、创建并使用自定义的类加载器" class="headerlink" title="八、创建并使用自定义的类加载器"></a>八、创建并使用自定义的类加载器</h3><h3 id="九、开启反射的源头Class"><a href="#九、开启反射的源头Class" class="headerlink" title="九、开启反射的源头Class"></a>九、开启反射的源头Class</h3><h3 id="十、获取Class实例的四种方式"><a href="#十、获取Class实例的四种方式" class="headerlink" title="十、获取Class实例的四种方式"></a>十、获取Class实例的四种方式</h3><h3 id="十一、从Class中获取信息"><a href="#十一、从Class中获取信息" class="headerlink" title="十一、从Class中获取信息"></a>十一、从Class中获取信息</h3><h3 id="十二、Proxy和InvocationHandler创建动态代理"><a href="#十二、Proxy和InvocationHandler创建动态代理" class="headerlink" title="十二、Proxy和InvocationHandler创建动态代理"></a>十二、Proxy和InvocationHandler创建动态代理</h3><h3 id="十三、动态代理和AOP（Aspect-Orient-Programming）"><a href="#十三、动态代理和AOP（Aspect-Orient-Programming）" class="headerlink" title="十三、动态代理和AOP（Aspect Orient Programming）"></a>十三、动态代理和AOP（Aspect Orient Programming）</h3><h3 id="十四、泛型和Class类"><a href="#十四、泛型和Class类" class="headerlink" title="十四、泛型和Class类"></a>十四、泛型和Class类</h3><h3 id="十五、使用反射来获取泛型信息"><a href="#十五、使用反射来获取泛型信息" class="headerlink" title="十五、使用反射来获取泛型信息"></a>十五、使用反射来获取泛型信息</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射机制与原理分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaIO流</title>
      <link href="posts/7wu77io3.html"/>
      <url>posts/7wu77io3.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、IO流结构体系"><a href="#一、IO流结构体系" class="headerlink" title="一、IO流结构体系"></a>一、IO流结构体系</h3><h3 id="二、IO流原理分析"><a href="#二、IO流原理分析" class="headerlink" title="二、IO流原理分析"></a>二、IO流原理分析</h3><h3 id="三、IO流的分类"><a href="#三、IO流的分类" class="headerlink" title="三、IO流的分类"></a>三、IO流的分类</h3><h3 id="四、IO流与文件操作"><a href="#四、IO流与文件操作" class="headerlink" title="四、IO流与文件操作"></a>四、IO流与文件操作</h3><h3 id="五、IO流的包装与链接"><a href="#五、IO流的包装与链接" class="headerlink" title="五、IO流的包装与链接"></a>五、IO流的包装与链接</h3><h3 id="六、缓冲流"><a href="#六、缓冲流" class="headerlink" title="六、缓冲流"></a>六、缓冲流</h3><h3 id="七、文件的复制和性能对比"><a href="#七、文件的复制和性能对比" class="headerlink" title="七、文件的复制和性能对比"></a>七、文件的复制和性能对比</h3><h3 id="八、对象流"><a href="#八、对象流" class="headerlink" title="八、对象流"></a>八、对象流</h3><h3 id="九、对象的序列化与反序列化"><a href="#九、对象的序列化与反序列化" class="headerlink" title="九、对象的序列化与反序列化"></a>九、对象的序列化与反序列化</h3><h3 id="十、控制台IO"><a href="#十、控制台IO" class="headerlink" title="十、控制台IO"></a>十、控制台IO</h3><h3 id="十一、标准输入流与标准输出流"><a href="#十一、标准输入流与标准输出流" class="headerlink" title="十一、标准输入流与标准输出流"></a>十一、标准输入流与标准输出流</h3><h3 id="十二、打印流"><a href="#十二、打印流" class="headerlink" title="十二、打印流"></a>十二、打印流</h3><h3 id="十三、转换流"><a href="#十三、转换流" class="headerlink" title="十三、转换流"></a>十三、转换流</h3><h3 id="十四、字符编码与解码"><a href="#十四、字符编码与解码" class="headerlink" title="十四、字符编码与解码"></a>十四、字符编码与解码</h3><h3 id="十五、RandomAccessFile类"><a href="#十五、RandomAccessFile类" class="headerlink" title="十五、RandomAccessFile类"></a>十五、RandomAccessFile类</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="posts/76fs5we6.html"/>
      <url>posts/76fs5we6.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、线程的原理"><a href="#一、线程的原理" class="headerlink" title="一、线程的原理"></a>一、线程的原理</h3><h3 id="二、线程的创建与启动"><a href="#二、线程的创建与启动" class="headerlink" title="二、线程的创建与启动"></a>二、线程的创建与启动</h3><h3 id="三、创建线程的几种方式对比"><a href="#三、创建线程的几种方式对比" class="headerlink" title="三、创建线程的几种方式对比"></a>三、创建线程的几种方式对比</h3><h3 id="四、继承Thread类与实现Runnable接口"><a href="#四、继承Thread类与实现Runnable接口" class="headerlink" title="四、继承Thread类与实现Runnable接口"></a>四、继承Thread类与实现Runnable接口</h3><h3 id="五、创建线程方式对比"><a href="#五、创建线程方式对比" class="headerlink" title="五、创建线程方式对比"></a>五、创建线程方式对比</h3><h3 id="六、线程的控制"><a href="#六、线程的控制" class="headerlink" title="六、线程的控制"></a>六、线程的控制</h3><h3 id="七、线程的调度"><a href="#七、线程的调度" class="headerlink" title="七、线程的调度"></a>七、线程的调度</h3><h3 id="八、线程的优先级"><a href="#八、线程的优先级" class="headerlink" title="八、线程的优先级"></a>八、线程的优先级</h3><h3 id="九、线程的生命周期"><a href="#九、线程的生命周期" class="headerlink" title="九、线程的生命周期"></a>九、线程的生命周期</h3><h3 id="十、多线程的安全问题与解决办法"><a href="#十、多线程的安全问题与解决办法" class="headerlink" title="十、多线程的安全问题与解决办法"></a>十、多线程的安全问题与解决办法</h3><h3 id="十一、线程的同步"><a href="#十一、线程的同步" class="headerlink" title="十一、线程的同步"></a>十一、线程的同步</h3><h3 id="十二、互斥锁"><a href="#十二、互斥锁" class="headerlink" title="十二、互斥锁"></a>十二、互斥锁</h3><h3 id="十三、线程的死锁问题"><a href="#十三、线程的死锁问题" class="headerlink" title="十三、线程的死锁问题"></a>十三、线程的死锁问题</h3><h3 id="十四、线程通信"><a href="#十四、线程通信" class="headerlink" title="十四、线程通信"></a>十四、线程通信</h3><h3 id="十五、生产者与消费者案例"><a href="#十五、生产者与消费者案例" class="headerlink" title="十五、生产者与消费者案例"></a>十五、生产者与消费者案例</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合与泛型</title>
      <link href="posts/34iuk7ab.html"/>
      <url>posts/34iuk7ab.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、集合框架概述"><a href="#一、集合框架概述" class="headerlink" title="一、集合框架概述"></a>一、集合框架概述</h3><h3 id="二、Collection系列集合"><a href="#二、Collection系列集合" class="headerlink" title="二、Collection系列集合"></a>二、Collection系列集合</h3><h3 id="三、List系列集合与Set系列集合"><a href="#三、List系列集合与Set系列集合" class="headerlink" title="三、List系列集合与Set系列集合"></a>三、List系列集合与Set系列集合</h3><h3 id="四、java-util-ArrayList源码与数据结构分析"><a href="#四、java-util-ArrayList源码与数据结构分析" class="headerlink" title="四、java.util.ArrayList源码与数据结构分析"></a>四、java.util.ArrayList源码与数据结构分析</h3><h3 id="五、java-util-LinkedList源码分析"><a href="#五、java-util-LinkedList源码分析" class="headerlink" title="五、java.util.LinkedList源码分析"></a>五、java.util.LinkedList源码分析</h3><h3 id="六、java-util-HashSet内部原理"><a href="#六、java-util-HashSet内部原理" class="headerlink" title="六、java.util.HashSet内部原理"></a>六、java.util.HashSet内部原理</h3><h3 id="七、java-util-TreeSet数据结构分析"><a href="#七、java-util-TreeSet数据结构分析" class="headerlink" title="七、java.util.TreeSet数据结构分析"></a>七、java.util.TreeSet数据结构分析</h3><h3 id="八、java7中Map系列集合与数据结构分析"><a href="#八、java7中Map系列集合与数据结构分析" class="headerlink" title="八、java7中Map系列集合与数据结构分析"></a>八、java7中Map系列集合与数据结构分析</h3><h3 id="九、java8中Map系列集合新特性对比"><a href="#九、java8中Map系列集合新特性对比" class="headerlink" title="九、java8中Map系列集合新特性对比"></a>九、java8中Map系列集合新特性对比</h3><h3 id="十、java-util-concurrent-ConcurrentHashMap"><a href="#十、java-util-concurrent-ConcurrentHashMap" class="headerlink" title="十、java.util.concurrent.ConcurrentHashMap"></a>十、java.util.concurrent.ConcurrentHashMap</h3><h3 id="十一、Iterator与Listlterator"><a href="#十一、Iterator与Listlterator" class="headerlink" title="十一、Iterator与Listlterator"></a>十一、Iterator与Listlterator</h3><h3 id="十二、Collections工具类"><a href="#十二、Collections工具类" class="headerlink" title="十二、Collections工具类"></a>十二、Collections工具类</h3><h3 id="十三、集合中使用的泛型"><a href="#十三、集合中使用的泛型" class="headerlink" title="十三、集合中使用的泛型"></a>十三、集合中使用的泛型</h3><h3 id="十四、自定义泛型"><a href="#十四、自定义泛型" class="headerlink" title="十四、自定义泛型"></a>十四、自定义泛型</h3><h3 id="十五、通配符"><a href="#十五、通配符" class="headerlink" title="十五、通配符"></a>十五、通配符</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java异常处理</title>
      <link href="posts/18d2b4e6.html"/>
      <url>posts/18d2b4e6.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、异常处理"><a href="#一、异常处理" class="headerlink" title="一、异常处理"></a>一、异常处理</h3><h3 id="二、异常的堆栈抛出机制"><a href="#二、异常的堆栈抛出机制" class="headerlink" title="二、异常的堆栈抛出机制"></a>二、异常的堆栈抛出机制</h3><h3 id="三、异常的结构体系"><a href="#三、异常的结构体系" class="headerlink" title="三、异常的结构体系"></a>三、异常的结构体系</h3><h3 id="四、受检与非检异常"><a href="#四、受检与非检异常" class="headerlink" title="四、受检与非检异常"></a>四、受检与非检异常</h3><h3 id="五、异常的处理"><a href="#五、异常的处理" class="headerlink" title="五、异常的处理"></a>五、异常的处理</h3><h3 id="六、try-catch示例"><a href="#六、try-catch示例" class="headerlink" title="六、try-catch示例"></a>六、try-catch示例</h3><h3 id="七、使用finally回收资源"><a href="#七、使用finally回收资源" class="headerlink" title="七、使用finally回收资源"></a>七、使用finally回收资源</h3><h3 id="八、throw制造异常"><a href="#八、throw制造异常" class="headerlink" title="八、throw制造异常"></a>八、throw制造异常</h3><h3 id="九、异常的处理方式之thows"><a href="#九、异常的处理方式之thows" class="headerlink" title="九、异常的处理方式之thows"></a>九、异常的处理方式之thows</h3><h3 id="十、Java7增强的throw语句"><a href="#十、Java7增强的throw语句" class="headerlink" title="十、Java7增强的throw语句"></a>十、Java7增强的throw语句</h3><h3 id="十一、方法重写与throws"><a href="#十一、方法重写与throws" class="headerlink" title="十一、方法重写与throws"></a>十一、方法重写与throws</h3><h3 id="十二、自定义异常"><a href="#十二、自定义异常" class="headerlink" title="十二、自定义异常"></a>十二、自定义异常</h3><h3 id="十三、实战中自定义异常的应用解析"><a href="#十三、实战中自定义异常的应用解析" class="headerlink" title="十三、实战中自定义异常的应用解析"></a>十三、实战中自定义异常的应用解析</h3><h3 id="十四、异常信息的访问"><a href="#十四、异常信息的访问" class="headerlink" title="十四、异常信息的访问"></a>十四、异常信息的访问</h3><h3 id="十五、Java程序的常见问题及解决方法"><a href="#十五、Java程序的常见问题及解决方法" class="headerlink" title="十五、Java程序的常见问题及解决方法"></a>十五、Java程序的常见问题及解决方法</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaAPI</title>
      <link href="posts/19d6a3e6.html"/>
      <url>posts/19d6a3e6.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、Warpper包装类"><a href="#一、Warpper包装类" class="headerlink" title="一、Warpper包装类"></a>一、Warpper包装类</h2><h3 id="二、装箱与拆箱"><a href="#二、装箱与拆箱" class="headerlink" title="二、装箱与拆箱"></a>二、装箱与拆箱</h3><h3 id="三、包装类的缓存分析"><a href="#三、包装类的缓存分析" class="headerlink" title="三、包装类的缓存分析"></a>三、包装类的缓存分析</h3><h3 id="四、字符串处理类"><a href="#四、字符串处理类" class="headerlink" title="四、字符串处理类"></a>四、字符串处理类</h3><h3 id="五、String类的使用与内存与原理"><a href="#五、String类的使用与内存与原理" class="headerlink" title="五、String类的使用与内存与原理"></a>五、String类的使用与内存与原理</h3><h3 id="六、String类的算法分析"><a href="#六、String类的算法分析" class="headerlink" title="六、String类的算法分析"></a>六、String类的算法分析</h3><h3 id="七、StringBuffer与StringBuilder"><a href="#七、StringBuffer与StringBuilder" class="headerlink" title="七、StringBuffer与StringBuilder"></a>七、StringBuffer与StringBuilder</h3><h3 id="八、字符串处理类性能分析"><a href="#八、字符串处理类性能分析" class="headerlink" title="八、字符串处理类性能分析"></a>八、字符串处理类性能分析</h3><h3 id="九、其他常用类"><a href="#九、其他常用类" class="headerlink" title="九、其他常用类"></a>九、其他常用类</h3><h3 id="十、Java-lang-System类"><a href="#十、Java-lang-System类" class="headerlink" title="十、Java.lang.System类"></a>十、Java.lang.System类</h3><h3 id="十一、Java-util-Date类"><a href="#十一、Java-util-Date类" class="headerlink" title="十一、Java.util.Date类"></a>十一、Java.util.Date类</h3><h3 id="十二、Java-text-SimpleDateFormat类"><a href="#十二、Java-text-SimpleDateFormat类" class="headerlink" title="十二、Java.text.SimpleDateFormat类"></a>十二、Java.text.SimpleDateFormat类</h3><h3 id="十三、Java-util-Calendar类"><a href="#十三、Java-util-Calendar类" class="headerlink" title="十三、Java.util.Calendar类"></a>十三、Java.util.Calendar类</h3><h3 id="十四、Java-lang-Math类"><a href="#十四、Java-lang-Math类" class="headerlink" title="十四、Java.lang.Math类"></a>十四、Java.lang.Math类</h3><h3 id="十五、Java-math-BingInteger类与Java-math-BigDecimal"><a href="#十五、Java-math-BingInteger类与Java-math-BigDecimal" class="headerlink" title="十五、Java.math.BingInteger类与Java.math.BigDecimal"></a>十五、Java.math.BingInteger类与Java.math.BigDecimal</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 包装、装箱、拆箱 </tag>
            
            <tag> String </tag>
            
            <tag> 核心类库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java高级类特性</title>
      <link href="posts/15d2a4e6.html"/>
      <url>posts/15d2a4e6.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、抽象类-（abstract）实际应用举例"><a href="#一、抽象类-（abstract）实际应用举例" class="headerlink" title="一、抽象类 （abstract）实际应用举例"></a>一、抽象类 （abstract）实际应用举例</h3><h3 id="二、接口（interface）的应用与常见问题"><a href="#二、接口（interface）的应用与常见问题" class="headerlink" title="二、接口（interface）的应用与常见问题"></a>二、接口（interface）的应用与常见问题</h3><h3 id="三、Java8-Java9-Java10对接口的改进"><a href="#三、Java8-Java9-Java10对接口的改进" class="headerlink" title="三、Java8/Java9/Java10对接口的改进"></a>三、Java8/Java9/Java10对接口的改进</h3><h3 id="四、Template-Method-设计模式"><a href="#四、Template-Method-设计模式" class="headerlink" title="四、Template Method 设计模式"></a>四、Template Method 设计模式</h3><h3 id="五、代理模式（Proxy）"><a href="#五、代理模式（Proxy）" class="headerlink" title="五、代理模式（Proxy）"></a>五、代理模式（Proxy）</h3><h3 id="六、类的成员之内部类"><a href="#六、类的成员之内部类" class="headerlink" title="六、类的成员之内部类"></a>六、类的成员之内部类</h3><h3 id="七、匿名内部类"><a href="#七、匿名内部类" class="headerlink" title="七、匿名内部类"></a>七、匿名内部类</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="八、Java8中匿名内部类的新特性"><a href="#八、Java8中匿名内部类的新特性" class="headerlink" title="八、Java8中匿名内部类的新特性"></a>八、Java8中匿名内部类的新特性</h3><h3 id="九、Enum枚举"><a href="#九、Enum枚举" class="headerlink" title="九、Enum枚举"></a>九、Enum枚举</h3><h3 id="十、枚举的属性与方法"><a href="#十、枚举的属性与方法" class="headerlink" title="十、枚举的属性与方法"></a>十、枚举的属性与方法</h3><h3 id="十一、接口实现枚举类"><a href="#十一、接口实现枚举类" class="headerlink" title="十一、接口实现枚举类"></a>十一、接口实现枚举类</h3><h3 id="十二、Annotation注解"><a href="#十二、Annotation注解" class="headerlink" title="十二、Annotation注解"></a>十二、Annotation注解</h3><h3 id="十三、JDK内置注解"><a href="#十三、JDK内置注解" class="headerlink" title="十三、JDK内置注解"></a>十三、JDK内置注解</h3><h3 id="十四、自定义注解"><a href="#十四、自定义注解" class="headerlink" title="十四、自定义注解"></a>十四、自定义注解</h3><h3 id="十五、元注解"><a href="#十五、元注解" class="headerlink" title="十五、元注解"></a>十五、元注解</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抽象类 </tag>
            
            <tag> 接口 </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 枚举 </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面对对象编程</title>
      <link href="posts/16s23sd4.html"/>
      <url>posts/16s23sd4.html</url>
      
        <content type="html"><![CDATA[<h3 id="面向对象编程（OOP：-Object-Oriented-Programming）"><a href="#面向对象编程（OOP：-Object-Oriented-Programming）" class="headerlink" title="面向对象编程（OOP： Object Oriented Programming）"></a>面向对象编程（OOP： Object Oriented Programming）</h3><h4 id="▪-面向对象编程初步"><a href="#▪-面向对象编程初步" class="headerlink" title="▪ 面向对象编程初步"></a>▪ 面向对象编程初步</h4><ul><li><p>面向过程：事务比较简单，可以用线性的思维去解决</p></li><li><p>面向对象：事务比较复杂，使用简单的线性思维无非解决</p></li><li><p>共同点：面向过程和面向对象都是解决实际问题的一种思维方式</p></li></ul><p>二者相辅相成，并不是对立的，解决复杂问题，通过面向对象方式便于我们从宏观上把握事物之间复杂的关系，方便我们分析整个系统；具体到微观操作，仍然用面向过程方式来处理</p><p>例如：</p><p>面向过程                                                            面向对象</p><p>1、踩离合                                                          驾驶员</p><p>2、挂挡                                                              汽车</p><p>3、踩油门，放离合                                           驾驶员开汽车</p><p>4、开了                                                               car.start（）；</p><h4 id="▪-类和对象"><a href="#▪-类和对象" class="headerlink" title="▪ 类和对象"></a>▪ 类和对象</h4><p>类可以生成对象，类是对象的抽象，对象是类的实例化</p><ul><li><h5 id="对象和类的概念"><a href="#对象和类的概念" class="headerlink" title="对象和类的概念"></a>对象和类的概念</h5></li><li><p>对象：是具体的事物</p></li><li><p>类：是对象的抽象（抽象  抽出象的部分）</p></li><li><p>先有具体的对象，然后抽象各个对象间象的部分，归纳出类通过类再认识其他对象</p></li><li><h5 id="对象的特征-属性（事物特征的描述）"><a href="#对象的特征-属性（事物特征的描述）" class="headerlink" title="对象的特征-属性（事物特征的描述）"></a>对象的特征-属性（事物特征的描述）</h5></li><li><p>属性-对象具有的各种特征</p></li><li><p>每个对象的每个属性都拥有特定值</p></li><li><p>例如：张浩和李明的年龄、姓名不一样</p></li><li><h5 id="对象的行为-方法（动作、行为）"><a href="#对象的行为-方法（动作、行为）" class="headerlink" title="对象的行为-方法（动作、行为）"></a>对象的行为-方法（动作、行为）</h5></li><li><p>方法-对象执行的操作</p></li><li><p>例如：收银员收银、打印账单、刷卡</p></li><li><p>对象：用来描述客观事物的一个实体，由一组属性和方法构成</p></li><li><h5 id="对象的属性和方法"><a href="#对象的属性和方法" class="headerlink" title="对象的属性和方法"></a><strong>对象的属性和方法</strong></h5></li><li><p>例如：</p></li></ul><table><thead><tr><th>类</th><th>对象的属性</th><th>对象的方法</th></tr></thead><tbody><tr><td>dog</td><td>color ：yellow</td><td>call</td></tr><tr><td></td><td>name：旺旺</td><td>run</td></tr><tr><td></td><td>age： 3</td><td>eat</td></tr><tr><td></td><td>variety： Welsh corgi</td><td>play</td></tr></tbody></table><ul><li><h5 id="从对象中抽象出“类”"><a href="#从对象中抽象出“类”" class="headerlink" title="从对象中抽象出“类”"></a>从对象中抽象出“类”</h5><p>例如：男人，女人———&gt;人“类”      </p></li><li><h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5></li></ul><p>​       <strong>类是模子，确定对象将会拥有的特征（属性）和行为（方法）</strong></p><p>​        <strong>类</strong></p><p>​        <strong>具有相同属性和方法的一组对象（抽象）的集合</strong></p><p>​        <strong>类是对象的类型</strong></p><p>​        <strong>不同于int类型：具有方法</strong></p><ul><li><h5 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a><strong>类和对象的关系</strong></h5><p>▪ 类是抽象的概念，仅仅是模板，比如说：“人”</p><p>▪ 对象是一个你能够看得到、摸得着的具体实体</p><p>例如：</p><table><thead><tr><th>人“类”</th></tr></thead><tbody><tr><td>特征（属性）：姓名，年龄，体重，身高</td></tr><tr><td>行为（方法）：衣食住行</td></tr><tr><td>特朗普，普京，小布什，克林顿都有相对应的特征和行为</td></tr></tbody></table><h5 id="对象和类的总结-A"><a href="#对象和类的总结-A" class="headerlink" title="对象和类的总结 A"></a>对象和类的总结 A</h5><p> <strong>对象和类的关系：特殊到一般，具体到抽象。</strong></p><p><strong> 类：我们叫做class。</strong> </p><p><strong> 对象：我们叫做Object, instance(实例)。以后我们说某个类的对象，某个类</strong></p><p><strong>的实例。是一样的意思。</strong></p><p><strong> 类可以看成一类对象的模板，对象可以看成该类的一个具体实例。</strong></p><p><strong> 类是用亍描述同一类形的对象的一个抽象的概念，类中定义了这一类对象所</strong></p><p><strong>应具有的静态和动态属性。</strong></p><p><strong> 对象是Java程序的核心，在Java程序中“万事万物皆对象”。</strong></p><p><strong> JDK提供了很多类供编程人员使用，编程人员也可定义自己的类。</strong></p></li><li><h5 id="类的属性-A"><a href="#类的属性-A" class="headerlink" title="类的属性 A"></a>类的属性 A</h5><p><strong>属性 field，或者叫成员变量</strong></p><p>属性用亍定义该类戒该类对象包含的数据戒者说静态属性。</p><p><strong>属性作用范围是整个类体</strong></p><p>在定义成员变量时可以对其初始化，如果丌对其初始化，Java使</p><p>用默认的值对其初始化。</p><p>(<strong>数值：0： 0.0  char:  \u0000  ,boolean :false,</strong> <strong>所有引</strong></p><p><strong>用类型:null)</strong> </p><p>属性定义格式：</p><p>（修饰符） 属性类型 属性名 =（默认值）；</p><table><thead><tr><th>修饰符</th><th>属性类型</th><th>属性名</th></tr></thead><tbody><tr><td>可以省略<br />public、protected、private、Static、final</td><td>可以是任何类型，基本数据类型、引用数据类型</td><td>合法的标识符即可，首字母小写，驼峰原则：aaaBbbCcc</td></tr></tbody></table></li><li><h5 id="类的方法-A"><a href="#类的方法-A" class="headerlink" title="类的方法 A"></a>类的方法 A</h5><p>▪ <strong>面向对象中，整个程序的基本单位是类，方法是从属于对象的</strong></p><p>▪ 方法定义格式：</p><p><strong>（修饰符） 方法返回值类型 方法名(形参列表 ) {</strong></p><p><strong>// n条语句</strong></p><p>  <strong>}</strong> </p><p>▪ JAVA中方法参数传递是：<strong>值的传递</strong></p></li><li><h5 id="Java-是面向对象的语言"><a href="#Java-是面向对象的语言" class="headerlink" title="Java 是面向对象的语言"></a>Java 是面向对象的语言</h5><p><strong>所有Java程序都以类class为组织单元</strong></p><p><strong>关键字class定义自定义的数据类型</strong></p><p>例如：下列的Helloworld这个类名</p><pre><code class="java">public class HelloWorld&#123;    public static void main(String[]args)&#123;        System.out.println(&quot;你好世界！&quot;);    &#125;&#125;</code></pre></li><li><p><strong>Java类模板</strong></p><p>▪ 类将现实世界中的概念模拟到计算机程序中</p><p>模板：</p><pre><code class="java">public class 类名&#123;    //1.定义属性部分    属性1的类型 属性1;    属性2的类型 属性2;    ......    ;    属性n的类型 属性n;    //2.定义方法部分    方法1;    方法2;    .....;    方法m;&#125;</code></pre></li><li><h5 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h5><p>▪ 定义一个类的步骤</p><p>1、定义类名</p><p>2、编写类的属性</p><p>3、编写类的方法</p><p><strong>类示例：</strong></p><p><img src="https://raw.githubusercontent.com/YoYopupunsi/PicGoImgbed/main/posts/20210314165827.jpg"></p></li><li><h5 id="创建和使用对象"><a href="#创建和使用对象" class="headerlink" title="创建和使用对象"></a>创建和使用对象</h5><p>– 创建对象</p><p>  ▪ 类名 对象名 = new 类名();</p><p>​     <code>Person person = new Person();</code></p><p>– 引用对象成员：使用“.”进行以下操作</p><p>  ▪ 引用类的属性：对象名.属性</p><p>  ▪ 引用类的方法：对象名.方法名()</p><p>​     <code>person.name = “码云&quot;; //给name属性赋值</code></p><p>​     <code>person.introduce(); //调用introduce()</code></p><p>对象示例：</p><pre><code class="java">..........................................public class InitialPerson&#123;    public static void main(String[]args)&#123;        //1、创建对象        Person person = new Person();        //2、初始化变量前        System.out.println();        //3、调用自我介绍的方法        person.introduce();        //4、给属性赋值        person.name = &quot;码云&quot;;        person.age = 18;        person.sex = &quot;男&quot;;        //5.初始化变量后        System.out.println();        //6、调用自我介绍的方法        person.introduce();       &#125;&#125;</code></pre><h5 id="创建和使用对象示例："><a href="#创建和使用对象示例：" class="headerlink" title="创建和使用对象示例："></a><strong>创建和使用对象示例：</strong></h5><p><strong>文件名：Teacher.java</strong></p><pre><code class="java">public class Teacher&#123;    //1.定义类的属性（成员变量）    String name;    String career;    String course;    int ofSchoolAge;    int a = 18;    //2.定义类的方法    //2.1定义一个实际参数    void play(String ball)&#123;        System.out.println(&quot;我正在踢&quot;+ball);    &#125;    //2.2定义一个形式参数    void eat()&#123;        System.out.println(&quot;我正在吃饭&quot;);    &#125;    //3.创建main方法，程序的入口    public static void main(String[]args)&#123;        //4.创建对象        Teacher teacher = new Teacher();        //5.输出打印对象属性        System.out.println(teacher.name);//null        System.out.println(teacher.career);//null        System.out.println(teacher.course);//null        System.out.println(teacher.ofSchoolAge);//0        //5.修改属性值，给属性赋值        teacher.name = &quot;码云&quot;;        teacher.career = &quot;软件工程&quot;;        teacher.course = &quot;算法&quot;;        teacher.ofSchoolAge = 10;        //6.输出打印对象属性        System.out.println(teacher.name);//码云        System.out.println(teacher.career);//软件工程        System.out.println(teacher.course);//算法        System.out.println(teacher.ofSchoolAge);//10        //7.调用类的方法        teacher.play(&quot;qiu&quot;);//我正在踢球        teacher.eat();    //我正在吃饭    &#125;&#125;</code></pre><h5 id="程序总结"><a href="#程序总结" class="headerlink" title="程序总结"></a>程序总结</h5><table><thead><tr><th>* 所有类定义的时候可以添加属性和方法，但是不是必须要写的<br/>*   一个java文件中可以定义N多个class，但是只能有一个public class并且public class的类名跟文件名保持一致<br/>* 属性：<br/>*   语法：<br/>*   （访问修饰符）   数据类型      属性名称  =  值；<br/><em><br/></em>   注意：<br/>*       定义属性的时候可以有值也可以没有值<br/>*       必须要包含类型和名称<br/><em><br/></em><br/>* 方法：表示行为<br/>*   语法：<br/>*    （访问修饰符）  返回值类型(任何类型)  方法名称（形参列表）{<br/>*               逻辑代码<br/><em><br/></em>       }<br/>*   注意：<br/>*       1、方法的访问修饰符可以不写<br/>*       2、方法可以有返回值，也可以没有，void表示没有返回值的意思<br/>*       3、形参列表可以有，也可以没有<br/>*       4、java中方法的传参都是值传递<br/><em><br/></em> 对象的创建和使用<br/>*       1、使用new关键字来创建对象<br/>*       ClassName objectName = new ClassName();<br/>*       2、对象的使用<br/>*           使用对象的时候可以通过  对象名称.属性  或者  对象名称.方法  来调用属性和方法</th></tr></thead><tbody><tr><td></td></tr></tbody></table></li></ul><h4 id="▪-局部变量和成员变量"><a href="#▪-局部变量和成员变量" class="headerlink" title="▪ 局部变量和成员变量"></a>▪ 局部变量和成员变量</h4><h5 id="▪-区别"><a href="#▪-区别" class="headerlink" title="▪ 区别"></a>▪ 区别</h5><table><thead><tr><th>区别</th><th>局部变量</th><th>成员变量</th></tr></thead><tbody><tr><td>声明位置不同</td><td>类中</td><td>方法中</td></tr><tr><td>作用范围不同</td><td>当前类的方法</td><td>当前方法</td></tr><tr><td>内存存放的位置</td><td>栈内存中</td><td>堆内存中</td></tr><tr><td>默认值</td><td>没有默认值</td><td>有默认值</td></tr></tbody></table><hr><ul><li><p>▪ 不同的方法中即使有同名的局部变量，没有关系，互不影响，建议相同**</p><p><img src="https://cdn.jsdelivr.net/gh/YoYopupunsi/PicGoImgbed/main/photograph/0001.png"></p></li><li><p>局部变量：</p></li><li><p>定义在方法中的变量称之为局部变量</p></li><li><p>作用域：<strong>从定义的位置开始到整个方法结束</strong></p></li><li><p>局部变量不包含默认值，如果没有使用当前变量的话，可以不赋值</p></li><li><p><strong>注意：局部变量只能在当前方法中使用，其他地方无法使用</strong></p></li><li><p>成员变量：</p></li><li><p>定义在方法外，类内的变量叫做成员变量（全局变量）</p></li><li><p>成员变量包含初始值：int 0 String null boolean false</p></li><li><p>作用域：<strong>整个类体内</strong></p></li></ul><ul><li><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4></li></ul><p><img src="https://cdn.jsdelivr.net/gh/YoYopupunsi/PicGoImgbed/main/photograph/0002.jpg%22"></p><h5 id="▪-Java中的对象和数组是通过引用对其操作的"><a href="#▪-Java中的对象和数组是通过引用对其操作的" class="headerlink" title="▪ Java中的对象和数组是通过引用对其操作的."></a>▪ Java中的对象和数组是通过引用对其操作的.</h5><p>– 引用可以理解为一种受限的指针</p><p>– 指针是可以进行不整数做加减运算的，两个指针空间也可以迚行大小比较运算和相减运算。引用进行，叧能进行赋值运算。</p><p>– 引用就是一个变量戒对象的别名（引用的本质是一个对象）；指针是一个段内存空间的地址(指向存储一个变量值的空间或一个对象的空间)</p><p><img src="https://cdn.jsdelivr.net/gh/YoYopupunsi/PicGoImgbed/main/photograph/0004.jpg%22"></p><ul><li><h5 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h5><p><strong>▪ 栈：</strong></p><p><strong>– 存放：局部变量</strong></p><p><strong>– 先进后出，自下而上存储</strong></p><p><strong>– 方法执行完毕，自动释放空间</strong></p><p><strong>▪ 堆：</strong></p><p><strong>– 存放new出来的对象</strong></p><p><strong>– 需要垃圾回收器来回收:System.gc()</strong></p><p><strong>▪ 方法区：</strong></p><p><strong>– 存放：类的信息(代码)、 static变量、字符串常量等.</strong></p><p>栈-先进后出，自下而上存储</p><p><img src="https://cdn.jsdelivr.net/gh/YoYopupunsi/PicGoImgbed/main/photograph/0005.jpg%22"></p></li><li><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类和对象 </tag>
            
            <tag> 封装 </tag>
            
            <tag> 继承 </tag>
            
            <tag> 多态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数组</title>
      <link href="posts/45as5de6.html"/>
      <url>posts/45as5de6.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、static修饰符"><a href="#一、static修饰符" class="headerlink" title="一、static修饰符"></a>一、static修饰符</h3><h3 id="二、类的成员之代码块"><a href="#二、类的成员之代码块" class="headerlink" title="二、类的成员之代码块"></a>二、类的成员之代码块</h3><h3 id="三、静态代码与非静态代码块"><a href="#三、静态代码与非静态代码块" class="headerlink" title="三、静态代码与非静态代码块"></a>三、静态代码与非静态代码块</h3><h3 id="四、单例（Singleton）设计模式"><a href="#四、单例（Singleton）设计模式" class="headerlink" title="四、单例（Singleton）设计模式"></a>四、单例（Singleton）设计模式</h3><h3 id="五、final修饰符"><a href="#五、final修饰符" class="headerlink" title="五、final修饰符"></a>五、final修饰符</h3><h3 id="六、包（package）的管理与作用"><a href="#六、包（package）的管理与作用" class="headerlink" title="六、包（package）的管理与作用"></a>六、包（package）的管理与作用</h3><h3 id="七、DOS命令行下编译器操作"><a href="#七、DOS命令行下编译器操作" class="headerlink" title="七、DOS命令行下编译器操作"></a>七、DOS命令行下编译器操作</h3><h3 id="八、使用jar命令打包应用程序"><a href="#八、使用jar命令打包应用程序" class="headerlink" title="八、使用jar命令打包应用程序"></a>八、使用jar命令打包应用程序</h3><h3 id="九、数组的创建与使用"><a href="#九、数组的创建与使用" class="headerlink" title="九、数组的创建与使用"></a>九、数组的创建与使用</h3><h3 id="十、一维数组与多维数组"><a href="#十、一维数组与多维数组" class="headerlink" title="十、一维数组与多维数组"></a>十、一维数组与多维数组</h3><h3 id="十一、数组的默认初始化与内存分析"><a href="#十一、数组的默认初始化与内存分析" class="headerlink" title="十一、数组的默认初始化与内存分析"></a>十一、数组的默认初始化与内存分析</h3><h3 id="十二、数组的常见算法分析"><a href="#十二、数组的常见算法分析" class="headerlink" title="十二、数组的常见算法分析"></a>十二、数组的常见算法分析</h3><h3 id="十三、操作数组的工具类Arrays"><a href="#十三、操作数组的工具类Arrays" class="headerlink" title="十三、操作数组的工具类Arrays"></a>十三、操作数组的工具类Arrays</h3><h3 id="十四、命令行参数"><a href="#十四、命令行参数" class="headerlink" title="十四、命令行参数"></a>十四、命令行参数</h3><h3 id="十五、可变参数"><a href="#十五、可变参数" class="headerlink" title="十五、可变参数"></a>十五、可变参数</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础语法</title>
      <link href="posts/7da56k7r.html"/>
      <url>posts/7da56k7r.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、流程控制语句的介绍"><a href="#一、流程控制语句的介绍" class="headerlink" title="一、流程控制语句的介绍"></a>一、流程控制语句的介绍</h3><h4 id="1-1、顺序结构"><a href="#1-1、顺序结构" class="headerlink" title="1.1、顺序结构"></a>1.1、<strong>顺序结构</strong></h4><ul><li>程序从上到下逐行地执行，中间没有任何判断和跳转。</li></ul><h4 id="1-2、分支结构"><a href="#1-2、分支结构" class="headerlink" title="1.2、分支结构"></a>1.2、<strong>分支结构</strong></h4><ul><li><p>根据条件，选择性地执行某段代码。</p></li><li><p>有if…else和switch-case两种分支语句。</p></li></ul><h4 id="1-3、循环结构"><a href="#1-3、循环结构" class="headerlink" title="1.3、循环结构"></a>1.3、<strong>循环结构</strong></h4><ul><li><p>根据循环条件，重复性的执行某段代码。</p></li><li><p>有while、do…while、for三种循环语句。</p></li><li><p>注：JDK1.5提供了foreach循环，方便的遍历集合、数组元素</p></li></ul><h3 id="二、顺序结构"><a href="#二、顺序结构" class="headerlink" title="二、顺序结构"></a>二、顺序结构</h3><h4 id="2-1、Java中定义成员变量时采用合法的前向引用"><a href="#2-1、Java中定义成员变量时采用合法的前向引用" class="headerlink" title="2.1、Java中定义成员变量时采用合法的前向引用"></a>2.1、Java中定义成员变量时采用合法的前向引用</h4><pre><code class="java">public class SequentialStructure&#123;    intnuma = 1;    intnumb = numa + 2;&#125;</code></pre><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210215223932.png?raw=true"></p><h3 id="三、if分支结构"><a href="#三、if分支结构" class="headerlink" title="三、if分支结构"></a>三、if分支结构</h3><h4 id="3-1、if分支结构的概念："><a href="#3-1、if分支结构的概念：" class="headerlink" title="3.1、if分支结构的概念："></a>3.1、if分支结构的概念：</h4><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210215232125.png?raw=true"></p><h4 id="3-2、if-else使用说明"><a href="#3-2、if-else使用说明" class="headerlink" title="3.2、if  else使用说明"></a>3.2、if  else使用说明</h4><ul><li>条件表达式必须是布尔表达式（关系表达式或逻辑表达式）、布尔变量</li><li>语句块只有一条执行语句时，一对{}可以省略，但建议保留</li><li>if-else语句结构，根据需要可以嵌套使用</li><li>当if-else结构是“多选一”时，最后的else是可选的，根据需要可以省略</li><li>当多个条件是“互斥”关系时，条件判断语句及执行语句间顺序无所谓当多个条件是“包含”关系时，“小上大下 / 子上父下”</li></ul><h4 id="3-3、相关案例"><a href="#3-3、相关案例" class="headerlink" title="3.3、相关案例"></a>3.3、相关案例</h4><pre><code class="java">/*if分支结构案例：去网吧上网应用：1.请用户输入身份信息并使用变量记录2.判断年龄是否满18岁*/import java.util.Scanner;public class Age&#123;    public static void main(String[]args)&#123;        //1.提示用户输入身份信息并使用变量接收记录        System.out.println(&quot;请您输入你的身份信息：&quot;)；        Scanner sc = new Scanner(System.in);        int Age = sc.nextInt();        //2.使用if分支结构判断身份信息年龄是否满十八岁        if(Age&gt;=18)&#123;            System.out.println(&quot;欢迎光临&quot;)        &#125;         System.out.println(&quot;未满18岁严禁上网&quot;)     &#125;    &#125;</code></pre><pre><code class="java">/*if分支结构案例：查找两个整数中的最大值应用：1.提示用户输入两个整数并使用变量记录2.使用if分支结构判断最大值并输出打印*/import java.util.Scanner;public class TwoIntMax&#123;    public static void main(String[]args)&#123;        System.out.println(&quot;请输入两个整数：&quot;);        //1.提示用户输入两个整数并使用变量记录        Scanner sc = new Scanner(System.in);        int na = sc.nextInt();        int nb = sc.nextInt();        //2.使用if分支结构判断最大值        /*        //方式一：使用两个if分支结构找最大值        if(na &gt;= nb)&#123;            System.out.println(&quot;最大值是：&quot; + na);        &#125;        if(na &lt; nb)&#123;            System.out.println(&quot;最大值是：&quot; + nb);        &#125;        */        //方式二：假设法：假设第一个数为最大值并使用变量记录，推荐使用此方式：通用性        int max = na;        if(nb &gt;= max)&#123;            max = nb;        //若if判断nb&gt;=max成立则输出max=nb，nb则为最大值        &#125;        //若if判断nb&gt;=max不成立则输出max，na则为最大值        System.out.println(&quot;最大值是：&quot;+ max)    &#125;&#125;</code></pre><pre><code class="java">/*if else分支结构案例：考试成绩是否合格1.提示用户输入成绩并使用变量记录2.使用if else分支结构判断输入的数值是否合格*/import java.util.Scanner;public class ExaminationGradeRating&#123;    public static void main(String[]args)&#123;        System.out.println(&quot;请您输入您的成绩：&quot;);        //1.提示用户输入成绩并使用变量记录        Scanner sc = new Scanner(System.in);        int eg = sc.nextInt();        //2.使用if else分支结构判断输入的数值是否合格        if(eg&gt;=60)&#123;            //3.if判断eg&gt;=60成立，则输出恭喜你，明年不用补考了            System.out.println(&quot;恭喜你，明年不用补考了&quot;);        &#125;        else&#123;            //4.if判断eg&gt;=60不成立，则输出明年继续补卡吧！            System.out.println(&quot;明年继续补考把！&quot;)        &#125;         &#125;&#125;</code></pre><pre><code class="java">/*提示用户输入一个整数，使用if else分支结构判断该整数是负数还是非负数并打印。• 使用if else分支结构判断该整数是正数、负数还是零。1.提示用户输入一个整数2.使用if else分支结构进行判断*/import java.util.Scanner;public class IfElse&#123;                            public static void main(String[]args)&#123;        System.out.println(&quot;请您输入一个整数：&quot;);        //1.提示用户输入一个整数并声明变量记录        Scanner sc = new Scanner(System.in);        int i = sc.nextInt();        //2.使用if else分支结构进行判断        if(i&gt;0)&#123;            //3.if判断i&gt;0成立，则您输入整数数字的为正数            System.out.println(&quot;您输入整数数字的为正数&quot;);        &#125;        if(i &lt; 0)&#123;            //4.if判断i&lt;0成立，则您输入整数数字的为负数            System.out.println(&quot;您输入整数数字的为负数&quot;);        &#125;        else&#123;            //5.上面语句不成立，则您输入整数数字的为零            System.out.println(&quot;您输入的整数数字为零&quot;);        &#125;    &#125;    &#125;</code></pre><pre><code class="java">/*根据用户输入的薪水计算个人所得税并打印出来1.提示用户输入薪资2.使用if elseif else分支结构判断薪水所在的范围*/public class IfElseIfElse&#123;    public static void main(String[]args)&#123;        System.out.println(&quot;请您输入您的薪水：&quot;);        Scanner sc = new Scanner(System.in);        int i = sc.next();        if(i &lt;= 5000)&#123;            System.out.println(&quot;您不用交税哟！&quot;);        &#125;        else if()    &#125;&#125;</code></pre><h3 id="四、switch选择结构与相关规则"><a href="#四、switch选择结构与相关规则" class="headerlink" title="四、switch选择结构与相关规则"></a>四、switch选择结构与相关规则</h3><h4 id="分支结构二"><a href="#分支结构二" class="headerlink" title="分支结构二"></a>分支结构二</h4><p>格式：</p><p>switch（常量）{</p><p>case 常量1：</p><p>​    语句块1;</p><p>case 常量2：</p><p>​    语句块2;</p><p>case 常量3：</p><p>​    语句块3;</p><p>case 常量4：</p><p>​    语句块4;</p><p>}</p><h3 id="五、循环结构"><a href="#五、循环结构" class="headerlink" title="五、循环结构"></a>五、循环结构</h3><h3 id="六、for循环"><a href="#六、for循环" class="headerlink" title="六、for循环"></a>六、for循环</h3><h3 id="七、while循环"><a href="#七、while循环" class="headerlink" title="七、while循环"></a>七、while循环</h3><h3 id="八、do-while循环语句"><a href="#八、do-while循环语句" class="headerlink" title="八、do-while循环语句"></a>八、do-while循环语句</h3><h3 id="九、各语句性能对比与应用场景"><a href="#九、各语句性能对比与应用场景" class="headerlink" title="九、各语句性能对比与应用场景"></a>九、各语句性能对比与应用场景</h3><h3 id="十、特殊流程控制语句"><a href="#十、特殊流程控制语句" class="headerlink" title="十、特殊流程控制语句"></a>十、特殊流程控制语句</h3><h4 id="10-1、break"><a href="#10-1、break" class="headerlink" title="10.1、break"></a>10.1、break</h4><h4 id="10-2、continue"><a href="#10-2、continue" class="headerlink" title="10.2、continue"></a>10.2、continue</h4><h4 id="10-3、return"><a href="#10-3、return" class="headerlink" title="10.3、return"></a>10.3、return</h4><h3 id="十一、方法的声明与使用（后面学习）"><a href="#十一、方法的声明与使用（后面学习）" class="headerlink" title="十一、方法的声明与使用（后面学习）"></a>十一、方法的声明与使用（后面学习）</h3><h3 id="十二、方法调用的过程分析（后面学习）"><a href="#十二、方法调用的过程分析（后面学习）" class="headerlink" title="十二、方法调用的过程分析（后面学习）"></a>十二、方法调用的过程分析（后面学习）</h3><h3 id="十三、跨类调用方法（后面学习）"><a href="#十三、跨类调用方法（后面学习）" class="headerlink" title="十三、跨类调用方法（后面学习）"></a>十三、跨类调用方法（后面学习）</h3><h3 id="十四、参数的值传递（后面学习）"><a href="#十四、参数的值传递（后面学习）" class="headerlink" title="十四、参数的值传递（后面学习）"></a>十四、参数的值传递（后面学习）</h3><h3 id="十五、方法的重载Overload（后面学习）"><a href="#十五、方法的重载Overload（后面学习）" class="headerlink" title="十五、方法的重载Overload（后面学习）"></a>十五、方法的重载Overload（后面学习）</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分支结构 </tag>
            
            <tag> 循环结构 </tag>
            
            <tag> 顺序结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程语言的概述</title>
      <link href="posts/14w2a4e6.html"/>
      <url>posts/14w2a4e6.html</url>
      
        <content type="html"><![CDATA[<h3 id="计算机语言介绍"><a href="#计算机语言介绍" class="headerlink" title="计算机语言介绍"></a>计算机语言介绍</h3><h4 id="一、机器语言"><a href="#一、机器语言" class="headerlink" title="一、机器语言"></a><strong>一、机器语言</strong></h4><p>​        简称机器码或原生码是用二进制代码表示能让CPU直接识别和执行的机器指令的集合，属于低级语言</p><p>​    用它来编写程序是非常繁琐的工作，表现如下几点：</p><ul><li>要熟记所用计算机的全部指令代码和代码的涵义</li><li>程序员自己要处理每条指令和每一数据的存储分配和输入输出，还要记住编程过程中每步所使用的工作单元处在何种状态</li><li>编写程序花费时间比运行时间远远大于几十倍甚至几百倍</li><li>程序中全部都是”0”和”1”指令代码，直观性差，容易出错，除了厂家专业人士外，绝大多数不再去学习它</li><li>指令部分的示例</li><li>0000代表加载（LOAD）</li><li>0001代表存储（STORE）</li><li>暂存器部分的示例</li><li>0000代表暂存器A</li><li>0001代表暂存器B</li><li>存储器部分的示例</li><li>000000000000代表地址为0的存储器</li><li>000000000001代表地址为1的存储器</li><li>000000010000代表地址为16的存储器</li><li>100000000000代表地址为2^11的存储器</li><li>集成示例</li><li>0000,0000,000000010000代表LOAD A,16</li><li>0000,0001,000000000001代表LOAD B,1</li><li>0001,0001,000000010000代表STORE,B,16</li><li>0001,0001,000000000001代表STORE,B,1</li></ul><h4 id="二、汇编语言"><a href="#二、汇编语言" class="headerlink" title="二、汇编语言"></a><strong>二、汇编语言</strong></h4><ul><li><p>简称符号语言，用标识符代替机器指令的操作码，跟机器语言一样，直接对硬件操作，也属于低级语言， 一般来说只有像Inel AMD等芯片厂商应用才广泛</p></li><li><p>汇编语言的主体是汇编指令。汇编指令和机器指令的差别在于指令的表示方法上。汇编指令是机器指令便于记忆的书写格式</p></li></ul><p>​        图例：</p><p>​        操作：寄存器BX的内容送到AX中</p><p>​        1000100111011000           机器指令</p><p>​         mov    ax，bx                     汇编指令</p><p> 其特点：</p><ul><li><p> 面向机器的低级语言，通常为特定的计算机或系列计算机专门设计</p></li><li><p> 保持了机器语言的优点，具有直接和简捷的特点</p></li><li><p> 可有效地访问、控制计算机的各种硬件设备，如磁盘、存储器、CPU、I/O端口等</p></li><li><p> 目标代码简短，占用内存少，执行速度快，是高效的程序设计语言</p></li><li><p> 经常与高级语言配合使用，应用十分广泛</p></li></ul><h4 id="三、高级语言"><a href="#三、高级语言" class="headerlink" title="三、高级语言"></a><strong>三、高级语言</strong></h4><p>​        是大多数编程者的选择，由于汇编语言依赖于硬件体系，且标识符量大难记，于是人们又发明了更加易用的所谓高级语言，使一般人易于接受的文字来表示，从而让程序员写得更容易，可读性更高，以便于对电脑认知较浅的人亦可以大概明白其内容</p><p>  高级语言所编制的程序不能直接被计算机识别，必须经过转换才能被执行，按转换方式可分为2类：</p><h5 id="1、-编译类"><a href="#1、-编译类" class="headerlink" title="1、 编译类"></a>1、 编译类</h5><p>​         事先编好一个叫做编译程序的机器语言程序放在计算机中，当高级语言编的源程序输入计算机时，编译程序就把整个源程序自动翻译成用机器指令表示的目标程序</p><p>​         使用比较方便、效率较高，但源程序一旦需要修改，必须先修改再重新编译整个源程序才执行，跨平台性较差，如C、C++、Delphi等</p><p>​        图例：</p><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213164208.png?raw=true"></p><h5 id="2、-解释类"><a href="#2、-解释类" class="headerlink" title="2、 解释类"></a>2、 解释类</h5><p>​         事先编好一个叫做解释程序的机器语言程序放在计算机中，当高级语言源程序输入计算机后，解释程序自动地逐句翻译源程序，译一句执行一句。</p><p>​        使用效率比较低，依赖解释器，跨平台性好，如Python，Java，Ruby等</p><p>​        编译的结果是另外一种语言，而解释的就是一种中间语言</p><p>​        图例：</p><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213164239.png?raw=true"></p><h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a><strong>四、总结</strong></h4><h5 id="1、机器语言"><a href="#1、机器语言" class="headerlink" title="1、机器语言"></a>1、机器语言</h5><p>​     优点是最底层，速度最快，缺点是最复杂，开发效率最低</p><h5 id="2、汇编语言"><a href="#2、汇编语言" class="headerlink" title="2、汇编语言"></a>2、汇编语言</h5><p>​     优点是比较底层，速度最快，缺点是复杂，开发效率最低</p><h5 id="3、高级语言"><a href="#3、高级语言" class="headerlink" title="3、高级语言"></a>3、高级语言</h5><p>​      编译型语言执行速度快，不依赖语言环境运行，跨平台差</p><p>​      解释型跨平台好，一分代码，到处可用，开发效率高，缺点是执行速度慢，依赖解释器运行</p><h3 id="Java语言的前世今生"><a href="#Java语言的前世今生" class="headerlink" title="Java语言的前世今生"></a>Java语言的前世今生</h3><h4 id="一、Java语言概述"><a href="#一、Java语言概述" class="headerlink" title="一、Java语言概述"></a>一、Java语言概述</h4><ul><li>是SUN(Stanford University Network，斯坦福大学网络公司 ) 1995年推出的一门高级编程语言</li><li>是一种面向Internet的编程语言。Java一开始富有吸引力是因为Java程序可以在Web浏览器中运行。这些Java程序被称为Java小程序（applet）。applet使用现代的图形用户界面与Web用户进行交互。 applet内嵌在HTML代码中</li><li>随着Java技术在web方面的不断成熟，已经成为Web应用程序的首选开发语言</li><li>后台开发语言：Java、PHP、Python、Go、Node.js</li></ul><h4 id="二、Java简史"><a href="#二、Java简史" class="headerlink" title="二、Java简史"></a>二、Java简史</h4><p>图例：</p><p><img src="https://img-blog.csdnimg.cn/20191117210522275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzNDUyMzg1,size_16,color_FFFFFF,t_70" alt="java简史"></p><h3 id="Java技术体系平台"><a href="#Java技术体系平台" class="headerlink" title="Java技术体系平台"></a>Java技术体系平台</h3><h5 id="一、Java-SE-Java-Standard-Edition-标准版"><a href="#一、Java-SE-Java-Standard-Edition-标准版" class="headerlink" title="一、Java SE(Java Standard Edition)标准版"></a>一、Java SE(Java Standard Edition)标准版</h5><p>支持面向桌面级应用（如Windows下的应用程序）的Java平台，提供了完整的Java核 心API，此版本以前称为J2SE</p><h5 id="二、Java-EE-Java-Enterprise-Edition-企业版"><a href="#二、Java-EE-Java-Enterprise-Edition-企业版" class="headerlink" title="二、Java EE(Java Enterprise Edition)企业版"></a>二、Java EE(Java Enterprise Edition)企业版</h5><p>是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如<br>:Servlet 、Jsp等，主要针对于Web应用程序开发。版本以前称为J2EE</p><h5 id="三、Java-ME-Java-Micro-Edition-小型版"><a href="#三、Java-ME-Java-Micro-Edition-小型版" class="headerlink" title="三、Java ME(Java Micro Edition)小型版"></a>三、Java ME(Java Micro Edition)小型版</h5><p>支持Java程序运行在移动终端（手机、PDA）上的平台，对Java API有所精简，并加入了针对移动终端的支持，此版本以前称为J2ME</p><h5 id="四、Java-Card"><a href="#四、Java-Card" class="headerlink" title="四、Java Card"></a>四、Java Card</h5><p>支持一些Java小程序（Applets）运行在小内存设备（如智能卡）上的平台</p><h3 id="JDK的安装与环境配置"><a href="#JDK的安装与环境配置" class="headerlink" title="JDK的安装与环境配置"></a>JDK的安装与环境配置</h3><h4 id="一、JDK下载及安装"><a href="#一、JDK下载及安装" class="headerlink" title="一、JDK下载及安装"></a>一、JDK下载及安装</h4><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143209.png?raw=true"></p><h4 id="二、JDK环境变量配置及测试"><a href="#二、JDK环境变量配置及测试" class="headerlink" title="二、JDK环境变量配置及测试"></a>二、JDK环境变量配置及测试</h4><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213163534.png?raw=true"></p><h3 id="JDK、JRE、JVM之间的关系"><a href="#JDK、JRE、JVM之间的关系" class="headerlink" title="JDK、JRE、JVM之间的关系"></a>JDK、JRE、JVM之间的关系</h3><p>• javac.exe - 编译器，主要用于将高级Java源代码翻译成字节码文件 </p><p>• java.exe - 解释器，主要用于启动JVM对字节码文件进行解释并执行</p><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143935.png?raw=true"></p><h3 id="Java核心机制及JVM运行原理"><a href="#Java核心机制及JVM运行原理" class="headerlink" title="Java核心机制及JVM运行原理"></a>Java核心机制及JVM运行原理</h3><h4 id="一、Java两种核心机制"><a href="#一、Java两种核心机制" class="headerlink" title="一、Java两种核心机制"></a>一、Java两种核心机制</h4><ul><li><h5 id="Java虚拟机-Java-Virtal-Machine"><a href="#Java虚拟机-Java-Virtal-Machine" class="headerlink" title="Java虚拟机 (Java Virtal Machine)"></a>Java虚拟机 (Java Virtal Machine)</h5></li></ul><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213160814.png?raw=true"></p><ul><li><h5 id="垃圾收集机制-Garbage-Collection"><a href="#垃圾收集机制-Garbage-Collection" class="headerlink" title="垃圾收集机制 (Garbage Collection)"></a>垃圾收集机制 (Garbage Collection)</h5><p>不再使用的内存空间应回收—— 垃圾回收</p><p>在C/C++等语言中，由程序员负责回收无用内存。Java 语言消除了程序员回收无用内存空间的责任：它提供一种系统级线程跟踪存储空间的分配情况。并在JVM空闲时，检查并释放那些可被释放的存储空间</p><p>垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预</p></li></ul><h3 id="Java程序执行原理"><a href="#Java程序执行原理" class="headerlink" title="Java程序执行原理"></a>Java程序执行原理</h3><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213163759.png?raw=true"></p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>​    用于注解说明解释程序的文字就是注释</p><p>​    Java中的注释类型：</p><p>​     单行注释</p><p>​    多行注释</p><p>​    文档注释 (java特有) </p><p>​    提高了代码的阅读性；调试程序的重要方法。 </p><p>​    注释是一个程序员必须要具有的良好编程习惯。</p><p>​    将自己的思想通过注释先整理出来，再用代码去体现</p><p>​    <strong>单行注释</strong></p><p>​    格式：</p><p>​     //注释文字</p><p>​    <strong>多行注释</strong></p><p>​    格式： </p><p>​    /* 注释文字 */ </p><p>​    注：</p><p>​    对于单行和多行注释，被注释的文字，不会被JVM（java虚拟机）解释执行。</p><p>​    多行注释里面不允许有多行注释嵌套</p><p>​    <strong>文档注释（Java特有）</strong></p><p>​    格式：</p><p><strong>**</strong>/</p><p><strong>@author</strong> <strong>指定</strong>java程序的作者</p><p><strong>@version</strong> <strong>指定源文件的版本</strong></p><p>*<strong>/</strong> </p><p>​    注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形</p><p>​    式体现的该程序的说明文</p><p>​    操作方式</p><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143211.jpg?raw=true" alt="文档注释"></p><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143212.jpg?raw=true" alt="文档注释"></p><pre><code class="java"> /** *HelloChina *@author YoYopupunsi *@version V1.0 *11:19 2021/1/30 0030 *备注：验证各类注释的注意事项 */public class HelloChina &#123;    public static void main(String[] args)&#123;        System.out.println(&quot;你好，中国！&quot;);    &#125;&#125;//验证：单行和多行注释，被注释的文字，不会被JVM（java虚拟机）解释执行//验证：多行注释不允许嵌套使用//单行注释不会被JVM解释执行/*多行注释不会被JVM解释执行 *//*验证：多行注释不允许嵌套使用你好中国HelloChina*///java: 需要class, interface或enum,多行注释不允许嵌套使用</code></pre><h3 id="开发第一个Java应用程序HelloWorld"><a href="#开发第一个Java应用程序HelloWorld" class="headerlink" title="开发第一个Java应用程序HelloWorld"></a>开发第一个Java应用程序HelloWorld</h3><pre><code class="java">public class one_code/*类名*/ &#123;/*类体*/    public static void main/*主方法名程序的入口*/(String[]args)&#123;/*主方法体*/        System.out.println(&quot;HelloWorld&quot;);//自动换行        System.out.print(&quot;我爱中国&quot;);//不换行        System.out.println(&quot;HelloChina&quot;);    &#125;&#125;/*对第一个程序HelloWorld总结：1.java程序编写-&gt;编译-&gt;运行的过程(1)编写：编写java代码保存.java结尾的源文件(2)编译：使用javac.exe命令编译java源文件生成.class的字节码文件,格式：javac 源文件名.javajavac one_code.java，后缀.java为了检验源文件是否编写错误(3)运行：使用java.exe命令解释运行.class的字节码文件，格式：java 类java one_code jvm解释运行字节码文件2.class 类名&#123;类体&#125;  main()主方法名，程序的入口&#123;主方法体&#125;3. 输出语句：System.out.println():先输出数据，然后换行System.out.print():只输出数据4.每一行执行语句都以&quot;;&quot;结束在java语言规范中，分号代表一个语句的结束。所以，即使分号前面没有任何内容，那么一个分号其实也代表一个语句（空语句）。5.编译的过程：编译以后，会生成一个或多个字节码文件。字节码文件的文件名与java源文件中的类名相同6.关于作用域的理解(1)个人理解：‘&#123;&#125;’花括号‘&#123;’是作用域的起点，&#39;&#125;&#39;是作用域的终点.(2)百度：中间部分就是一个代码块，代码块决定其中定义的变量的作用域，代码块由若干语句组成，必须用大括号括起来，形成一个复合语句，多个复合语句可以嵌套在另外的一对大括号中形成更复杂的复合语句.说得简单点就是在哪个大括号中声明的变量其作用域就是该大括号范围内.代码块决定了变量的作用域，作用域决定了变量的“可见性”以及“存在时间”. */// 7.验证java源文件是否可以声明多个class？// 在一个java源文件中可以声明多个class。但是，只能最多有一个类声明为public的。// 而且要求声明为public的类的类名必须与源文件名相同。///*public class he&#123;&#125;编译错误：类he是公共的，应在名为he.java的文件中声明 */class woman&#123;&#125;class man&#123;&#125;</code></pre><h3 id="Java-Code-Style"><a href="#Java-Code-Style" class="headerlink" title="Java Code Style"></a>Java Code Style</h3><p>代码整洁之道(已整理，关于标识符)</p><p>第2章 有意义的命名<br>2.1 介绍<br>软件中随处可见命名。我们给变量、函数、参数、类和包命名。我们给源代码及源代码所在目录命名<br>这么多命名要做，不妨做好它。下文列出了取个好名字的几条简单规则</p><p>2.2 名副其实,见名知意<br>     变量名太随意，haha、list1、ok、theList 这些都没啥意义</p><p>2.3 避免误导<br>     包含List、import、java等类名、关键字或特殊字；<br>     字母o与数字0，字母l与数字1等<br>     提防使用不同之处较小的名称。比如：XYZControllerForEfficientHandlingOfStrings与XYZControllerForEfficientStorageOfStrings</p><p>2.4 做有意义的区分<br>     反面教材，变量名：a1、a2、a3<br>     避免冗余，不要出现Variable、表字段中避免出现table、字符串避免出现nameString，直接name就行，知道是字符串类型<br>     再比如：定义了两个类：Customer类和CustomerObject类，如何区分？<br>         定义了三个方法：getActiveAccount()、getActiveAccounts()、getActiveAccountInfo()，如何区分？</p><p>2.5 使用读得出来的名称<br>     不要使用自己拼凑出来的单词，比如：xsxm(学生姓名)；genymdhms(生成日期，年、月、日、时、分、秒)<br>     所谓的驼峰命名法，尽量使用完整的单词</p><p>2.6 使用可搜索的名称<br>     一些常量，最好不直接使用数字，而指定一个变量名，这个变量名可以便于搜索到.<br>     比如：找MAX_CLASSES_PER_STUDENT很容易，但想找数字7就麻烦了。</p><p>2.7 避免使用编码<br>     2.7.1 匈牙利语标记法<br>           即变量名表明该变量数据类型的小写字母开始。例如，szCmdLine的前缀sz表示“以零结束的字符串”<br>     2.7.2 成员前缀<br>          避免使用前缀，但是Android中一个比较好的喜欢用m表示私有等，个人感觉比较好<br>     2.7.3 接口和实现<br>          作者不喜欢把接口使用I来开头，实现也希望只是在后面添加Imp</p><p>2.8 避免思维映射<br>     比如传统上惯用单字母名称做循环计数器。所以就不要给一些非计数器的变量命名为：i、j、k等</p><p>2.9  类名<br>     类名与对象名应该是名词与名词短语。如Customer、WikiPage、Account和AddressParser。避免使用Data或Info这样的类名。<br>     不能使动词。比如：Manage、Process</p><p>2.10 方法名<br>     方法名应当是动词或者动词短语。如postPayment、deletePage或save</p><p>2.11 别扮可爱<br>     有的变量名叫haha、banana<br>     别用eatMyShorts()表示abort()</p><p>2.12 每个概念对应一个词<br>     项目中同时出现controllers与managers，为什么不统一使用其中一种？<br>     对于那些会用到你代码的程序员，一以贯之的命名法简直就是天降福音。</p><p>2.13 别用双关语<br>     有时可能使用add并不合适，比例insert、append。add表示完整的新添加的含义。     </p><p>2.14 使用解决方案领域名称<br>     看代码的都是程序员，所以尽量用那些计算机科学术语、算法名、模式名、数学术语，<br>     依据问题所涉领域来命名不算是聪明的做法</p><p>2.15 使用源自所涉问题领域的名称<br>     如果不能用程序员熟悉的术语来给手头的工作命名，就采用从所涉问题领域而来的名称吧。<br>     至少，负责维护代码的程序员就能去请教领域专家了</p><p>2.16 添加有意义的语境<br>     可以把相关的变量放到一个类中，使用这个类来表明语境</p><p>2.17 不要添加没用的语境<br>     名字中带有项目的缩写，这样完全没有必要。比如有一个名为“加油站豪华版”（Gas Station Deluxe）的项目，<br>     在其中给每个类添加GSD前缀就不是什么好策略</p><p>2.18 最后的话<br>     取好名字最难的地方在于需要良好的描述技巧和共有文化背景</p><h3 id="变量的声明和使用"><a href="#变量的声明和使用" class="headerlink" title="变量的声明和使用"></a>变量的声明和使用</h3><h4 id="一、标识符"><a href="#一、标识符" class="headerlink" title="一、标识符"></a>一、标识符</h4><h5 id="1、标识符"><a href="#1、标识符" class="headerlink" title="1、标识符"></a>1、标识符</h5><ul><li>Java 对各种<strong>变量</strong>、<strong>方法</strong>和<strong>类</strong>等要素命名时使用的字符序列称为标识符</li><li><strong>技巧：凡是自己可以起名字的地方都叫标识符</strong>。 </li></ul><h5 id="2、定义合法标识符规则"><a href="#2、定义合法标识符规则" class="headerlink" title="2、定义合法标识符规则"></a>2、定义合法标识符规则</h5><ul><li><p><strong>由26个英文字母大小写，0-9 _或 $组成</strong></p></li><li><p><strong>数字不可以开头</strong></p></li><li><p><strong>不可以使用关键字和保留字，但能包含关键字和保留字</strong></p></li><li><p><strong>Java中严格区分大小写，长度无限制</strong></p></li><li><p><strong>标识符不能包含空格</strong></p></li></ul><h5 id="3、Java中的名称命名规范："><a href="#3、Java中的名称命名规范：" class="headerlink" title="3、Java中的名称命名规范："></a>3、Java中的名称命名规范：</h5><ul><li><p><strong>包名</strong>：多单词组成时所有字母都小写：aaabbbccc</p></li><li><p><strong>类名、接口名</strong>：多单词组成时，所有单词的首字母大写：AaaBbbCcc</p></li><li><p><strong>变量名、方法名</strong>：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：aaaBbbCcc</p></li><li><p><strong>常量名</strong>：所有字母都大写。多单词时每个单词用下划线连接：AAA_BBB_CCC</p></li><li><p>注意1：在起名字时，为了提高阅读性，要尽量有意义，“见名知意”。</p></li><li><p>注意2：java采用unicode字符集，因此标识符也可以使用汉字声明，但是不建议使用。</p></li></ul><h4 id="二、变量的概念"><a href="#二、变量的概念" class="headerlink" title="二、变量的概念"></a>二、变量的概念</h4><ul><li>内存中的一个存储区域</li><li>该区域的数据可以在同一类型范围内不断变化</li><li>变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值</li></ul><h4 id="三、变量的作用"><a href="#三、变量的作用" class="headerlink" title="三、变量的作用"></a>三、变量的作用</h4><ul><li>用于在内存中保存数据</li></ul><h4 id="四、变量注意事项"><a href="#四、变量注意事项" class="headerlink" title="四、变量注意事项"></a>四、变量注意事项</h4><ul><li>Java中每个变量必须先声明，后使用</li><li>使用变量名来访问这块区域的数据</li><li>变量的作用域：其定义所在的一对{ }内 </li><li>变量只有在其作用域内才有效</li><li>同一个作用域内，不能定义重名的变量</li></ul><h4 id="五、声明变量"><a href="#五、声明变量" class="headerlink" title="五、声明变量"></a>五、声明变量</h4><ul><li>语法：数据类型    变量名称</li><li>例如：int var;</li></ul><h4 id="六、变量的赋值"><a href="#六、变量的赋值" class="headerlink" title="六、变量的赋值"></a>六、变量的赋值</h4><ul><li>语法：变量名称 = 值</li><li>例如：var = 10;</li></ul><h4 id="七、声明和赋值变量"><a href="#七、声明和赋值变量" class="headerlink" title="七、声明和赋值变量"></a>七、声明和赋值变量</h4><ul><li><p>语法： 数据类型    变量名 = 初始化值</p></li><li><p>例如：int var = 10;</p></li><li><p>对于每一种数据都定义了明确的具体数据类型（强类型语言），在内存中分</p><p>配了不同大小的内存空间</p></li></ul><h4 id="八、变量的分类-按声明的位置的不同"><a href="#八、变量的分类-按声明的位置的不同" class="headerlink" title="八、变量的分类-按声明的位置的不同"></a>八、变量的分类-按声明的位置的不同</h4><ul><li><p><strong>在方法体外，类体内声明的变量称为成员变量</strong> </p></li><li><p><strong>在方法体内部声明的变量称为局部变量</strong></p></li><li><p><strong>注意：二者在初始化值方面的异同:</strong></p></li></ul><p>​       <strong>同：都有生命周期</strong>     <strong>异：局部变量除形参外，需显式初始化</strong></p><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143213.png?raw=true" alt="变量的分类"></p><h5 id="变量-代码："><a href="#变量-代码：" class="headerlink" title="变量-代码："></a>变量-代码：</h5><pre><code class="java">/** * @Author: YoYopupunsi * @Description: * @Date: Created in 11:00 2021/2/1 0001 * @Modified By: *//*变量的使用1. java定义变量的格式：数据类型 变量名 = 变量值;数据类型 变量名;变量名 = 变量值;2. 说明：   ① 变量必须先声明，后使用   ② 变量都定义在其作用域内。在作用域内，它是有效的。换句话说，出了作用域，就失效了   ③ 同一个作用域内，不可以声明两个同名的变量*/public class variable_code &#123;    public static void main(String[] args) &#123;        //1.变量的定义(输入)        int Var = 10;        //2.变量的使用（输出）        System.out.println(Var);        //编译错误：使用Var之前并未定义过Var        //System.out.println(Var);        //3.变量的声明        //int Var;        //编译错误：使用Var之前并未赋值过Var        //System.out.println(Var);        //4.变量的赋值        //Var = 1001;        //编译不通过        //System.out.println(Var);        //5.不可以在同一个作用域内定义同名的变量        //int Var = 22;    &#125;&#125;</code></pre><h5 id="案例题目："><a href="#案例题目：" class="headerlink" title="案例题目："></a><strong>案例题目：</strong></h5><p>• 提示用户从键盘输入自己的姓名和年龄信息并打印出来</p><pre><code class="java">/** * @Author: YoYopupunsi * @Description: * @Date: Created in 12:16 2021/2/1 0001 * @Modified By: *//** 变量案例：提示用户从键盘输入自己的姓名和年龄信息并打印出来*分析：*1.声明两个变量用于记录姓名和年龄信息*2.提示用户从键盘输入姓名和年龄信息并放入到变量中   变量随使用随声明*3.打印变量的数值     尽可能减少重复的代码* */import java.util.Scanner;public class VariableCase_1 &#123;    public static void main(String[] args) &#123;        // 1.声明两个变量用于记录姓名和年龄信息        //String name;        //int age;        // 2.提示用户从键盘输入姓名和年龄信息并放入到变量中        System.out.println(&quot;请输入您的姓名：&quot;);        // 创建一个扫描器来扫描键盘输入的内容  System.in代表键盘输入        Scanner sc = new Scanner(System.in);        // 通过扫描器读取一个字符串数据放入变量name中        String name = sc.next();        System.out.println(&quot;请输入您的年龄：&quot;);        Scanner sc1 = new Scanner(System.in);        // 通过扫描器读取一个整数数据放入变量age中        int age = sc1.nextInt();        // 3.打印变量的数值        System.out.println(&quot; 姓名： &quot; + name + &quot;\n 年龄： &quot; + age);    &#125;&#125;</code></pre><h3 id="数据类型的分类"><a href="#数据类型的分类" class="headerlink" title="数据类型的分类"></a>数据类型的分类</h3><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143214.png?raw=true"></p><h4 id="一、进制"><a href="#一、进制" class="headerlink" title="一、进制"></a>一、进制</h4><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143215.png?raw=true"></p><ul><li>正十进制转换为二进制的方式：</li></ul><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143216.jpg?raw=true"></p><ul><li>正二进制转换为十进制的方式：</li></ul><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143217.jpg?raw=true"></p><ul><li>负十进制转换为二进制的方式：</li></ul><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143218.jpg?raw=true"></p><ul><li>负二进制转换为十进制的方式：</li></ul><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143219.jpg?raw=true"></p><ul><li><strong>单个字节表示的范围：</strong></li></ul><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143220.jpg?raw=true"></p><h4 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h4><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143221.png?raw=true"></p><ul><li>转义字符<img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143906.png?raw=true"></li><li>ASCII表<img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143907.png?raw=true"></li><li>相关代码<img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143908.png?raw=true"></li></ul><h4 id="三、基本数据类型之间的转换"><a href="#三、基本数据类型之间的转换" class="headerlink" title="三、基本数据类型之间的转换"></a>三、基本数据类型之间的转换</h4><ul><li><p>自动数据类型转换：表示将变量b的数值赋值给变量s，并覆盖变量s中原来的数值，相当于从byte类型到short类型的转换，小到大自动转换</p><p>![自动数据类型转换](D:\project\project_java\01_Java_模块一_一阶段\02_任务二： 变量和数据类型\04_picture\05_image-20210204102841415.png)</p></li><li><p>强制数据类型转换：表示将变量i的数值赋值给变量s，并覆盖变量s中原来的数值，相当于从int类型到short类型的转换，大到小强制转换（精度会有损失）</p></li><li><p>相关代码</p><pre><code class="java">/** * @Author: YoYopupunsi * @Description: * @Date: Created in 10:56 2021/2/2 0002 * @Modified By: */public class DataTypeConversion &#123;    public static void main(String[] args)&#123;        //1.首先声明变量接收各个数据类型        byte b = 1;        short s = 12;        int i = 127;        long l = 1234567891011L;        char c = &#39;a&#39;;        boolean bo1 = true;        boolean bo2 = false;        float f = 3.14159f;        double d = 3.141592653545;        //2.先打印各个数据类型的值        System.out.println(&quot;b的值为：&quot; + b);//127        System.out.println(&quot;s的值为：&quot; + s);//32767        System.out.println(&quot;i的值为：&quot; + i);//388883        System.out.println(&quot;l的值为：&quot; + l);//1234567891011L        System.out.println(&quot;c的值为：&quot; + c);//a        System.out.println(&quot;bo1的值为：&quot; + bo1);//true        System.out.println(&quot;bo2的值为：&quot; + bo2);//false        System.out.println(&quot;f的值为：&quot; + f);//3.14159        System.out.println(&quot;d的值为：&quot; + d);//3.141592653545        //3.首先测试自动数据类型转换：表示将变量b的数值赋值给变量s，并覆盖变量s中原来的数值，相当于从byte类型到short类型的转换，小到大自动转换        s = b;//        System.out.println(&quot;b的值为：&quot; + b);//1        System.out.println(&quot;s的值为：&quot; + s);//1        i =s;        System.out.println(&quot;i的值为：&quot; + i);//1        System.out.println(&quot;s的值为：&quot; + s);//1        //4.测试强制数据类型转换：表示将变量i的数值赋值给变量s，并覆盖变量s中原来的数值，相当于从int类型到short类型的转换，大到小强制转换        //s = i;//java: 不兼容的类型: 从int转换到short可能会有损失        //正确格式：        i = 127;        s = (short) i;        System.out.println(&quot;i的值为：&quot; + i);        System.out.println(&quot;s的值为：&quot; + s);        System.out.println(&quot;s的值为：&quot; + (int) s);    &#125;&#125;</code></pre></li></ul><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="一-算术运算符"><a href="#一-算术运算符" class="headerlink" title="一.算术运算符"></a>一.算术运算符</h4><p>• + 表示加法运算符</p><p>• - 表示减法运算符</p><p>• * 表示乘法运算符</p><p>• / 表示除法运算符</p><p>• % 表示取模/取余运算符</p><h4 id="二-字符串连接运算符"><a href="#二-字符串连接运算符" class="headerlink" title="二.字符串连接运算符"></a>二.字符串连接运算符</h4><p>• + 可以实现字符串的连接。同时可以实现字符串与其他数据类型“相连”。</p><h5 id="算术运算符几个问题的验证-如下列代码："><a href="#算术运算符几个问题的验证-如下列代码：" class="headerlink" title="算术运算符几个问题的验证(如下列代码：)"></a><strong>算术运算符几个问题的验证(如下列代码：)</strong></h5><p><u><strong>1.若希望保留小数部分该如何处理？</strong></u></p><p>处理方式一：使用强制类型转换将其中一个操作数转换为double类型再运算即可</p><p>处理方式二：使用 变量*1.0 打印即可</p><p><strong><u>2.算术运算符中%能对负数取模吗？取模一定为正数吗？验证：</u></strong></p><p>结论：负数参与的取模运算规则：先忽略负号，按照正数运算之后，被取模的数是正数结果就取正，反之取负。（注：(-2)%5中被取模数是-2,(-5)%2中被取模数是-1）</p><p><strong><u>3.对于除号“/”，它的整数除和小数除的区别是什么？验证：</u></strong></p><p>结论：整数之间做除法时，只保留整数部分而舍弃小数部分，整数与小数相除的结果为小数，小数除的结果为小数</p><p>*<em><u>4.=  +=   -=   <em>=  /=  %=   里面隐藏了强制类型转换</u></em></em></p><p>byte x += 10;     —&gt; x = (byte)(x + 10);</p><h5 id="案例题目-提示用户输入正整数类型的秒数，拆分秒数后输出x小时x分x秒。-如：输入xxxx，输出x小时x分x秒。"><a href="#案例题目-提示用户输入正整数类型的秒数，拆分秒数后输出x小时x分x秒。-如：输入xxxx，输出x小时x分x秒。" class="headerlink" title="**案例题目:**提示用户输入正整数类型的秒数，拆分秒数后输出x小时x分x秒。 如：输入xxxx，输出x小时x分x秒。"></a>**案例题目:**提示用户输入正整数类型的秒数，拆分秒数后输出x小时x分x秒。 如：输入xxxx，输出x小时x分x秒。</h5><pre><code class="java">import java.util.Scanner;public class ArithmeticOperatorsAndCases &#123;    public static void main(String[] args) &#123;        //算术运算学习：        //1.声明两个int变量并初始化        //int Ari1        //int Ari2        int Ari1 = 20, Ari2 = 10;        //分别为+ - * / %        int Add = Ari1 + Ari2;//声明一个变量Add记录Ari1，Ari2的和        int Sub = Ari1 - Ari2;//声明一个变量Sub记录Ari1，Ari2的差        int Mul = Ari1 * Ari2;//声明一个变量Mul记录Ari1，Ari2的乘积        int Div = Ari1 / Ari2;//声明一个变量Div记录Ari1，Ari2的除法        int Sur = Ari1 % Ari2;//声明一个变量Sur记录Ari1，Ari2的取余        System.out.println(&quot;Ari1，Ari2的和为：&quot; + Add + &quot;\nAri1，Ari2的差为：&quot; + Sub + &quot;\nAri1，Ari2的乘积为：&quot; + Mul + &quot;\nAri1，Ari2的除法为：&quot; + Div + &quot;\nAri1，Ari2的取余为：&quot; + Sur);        //Ari1，Ari2的和为：30  Ari1，Ari2的差为：10  Ari1，Ari2的乘积为：200  Ari1，Ari2的除法为：2  Ari1，Ari2的取余为：0        //若希望保留小数部分该如何处理？        //处理方式一：使用强制类型转换将其中一个操作数转换为double类型再运算即可        System.out.println(&quot;Ari1，Ari2的和为：&quot; + (double)Add);        //处理方式二：使用 变量*1.0 打印即可        System.out.println(&quot;Ari1，Ari2的和为：&quot; + Add*1.0);        //算术运算符中%能对负数取模吗？取模一定为正数吗？验证：        //1.首先声明并赋值两个整数型的变量记录        int Sur1 = 5,Sur2 = -2;        //2.声明一个变量Sur3记录Sur1，Sur2的取模        int Sur3 = Sur1 % Sur2;        System.out.println(&quot;Sur1，Sur2的取模为:&quot; + Sur3);//Sur1，Sur2的取模为:1        //3.声明一个变量Sur4记录Sur1，Sur2的取模        int Sur4 = Sur2 % Sur1;        System.out.println(&quot;Sur1，Sur2的取模为:&quot; + Sur4);//Sur1，Sur2的取模为:-2        //4.声明并赋值两个整数型的变量记录        int Sur5 = -5,Sur6 = 2;        //5.声明一个变量Sur8记录Sur5，Sur6的取模        int Sur7 = Sur5 % Sur6;        System.out.println(&quot;Sur5，Sur6的取模为:&quot; + Sur7);//Sur5，Sur6的取模为:-1        //6.声明一个变量Sur8记录Sur5，Sur6的取模        int Sur8 = Sur6 % Sur5;        System.out.println(&quot;Sur5，Sur6的取模为:&quot; + Sur8);//Sur5，Sur6的取模为:2        //结论：负数参与的取模运算规则：先忽略负号，按照正数运算之后，被取模的数是正数结果就取正，反之取负。（注：(-2)%5中被取模数是-2,(-5)%2中被取模数是-1）        //对于除号“/”，它的整数除和小数除的区别是什么？        double d = 10.2,e = 5.2;        int i=314;i=i/1000*1000;        System.out.println(&quot;double的除法:&quot; + d/e);//1.9615384615384612        System.out.println(&quot;double/int的除法:&quot; + d/Ari2);//1.02        System.out.println(&quot;i为:&quot; + i);//300        //结论：整数之间做除法时，只保留整数部分而舍弃小数部分，整数与小数相除的结果为小数，小数除的结果为小数。        //案例题目：• 提示用户输入正整数类型的秒数，拆分秒数后输出x小时x分x秒。• 如：输入xxxx，输出x小时x分x秒。        //1.提示用户输入正整数类型的秒数        System.out.println(&quot;请您输入正整数类型的秒数：&quot;);        //2.使用变量记录用户输入的正整数型的秒数        Scanner sc = new Scanner(System.in);        int Sec1 = sc.nextInt();        //3.将正整数的秒数拆分为时分秒后并使用变量记录        int Hour = Sec1 / 60 / 60;        int Minute = Sec1 % 3600 /60;        int Second = Sec1 % 60;        System.out.println(&quot;时间为：&quot; + Hour + &quot;小时&quot; + Minute + &quot;分钟&quot; + Second + &quot;秒&quot;);    &#125;&#125;</code></pre><h4 id="三、关系-比较运算符"><a href="#三、关系-比较运算符" class="headerlink" title="三、关系/比较运算符"></a>三、关系/比较运算符</h4><p>• &gt; 表示是否大于运算符 </p><p>&gt;= 表示是否大于等于运算符</p><p>• &lt; 表示是否小于运算符 </p><p>&lt;= 表示是否小于等于运算符</p><p>• == 表示是否等于运算符 </p><p>!= 表示是否不等于运算符</p><p>• 所有以关系运算符作为最终运算的表达式结果一定是boolean类型。</p><p>相关代码：</p><pre><code class="java">/** * @Author: YoYopupunsi * @Description: * @Date: Created in 2:26 2021/2/3 0003 * @Modified By: */import java.util.Scanner;public class ComparisonOperatorsAndCases &#123;    public static void main(String[] args)&#123;        // 1.声明两个int类型的变量并初始化        int i = 5;        int j = 2;        // 2.使用变量实现关系运算符的使用并打印结果        boolean k = i &gt; j;        System.out.println(&quot;k = &quot; + k); // k = true        System.out.println(i &gt; j);   // 是否大于      true        System.out.println(i &gt;= j);  // 是否大于或等于 true        System.out.println(i &lt; j);   // 是否小于    false        System.out.println(i &lt;= j);  // 是否小于等于 false        System.out.println(i == j);  // 是否等于    false        System.out.println(i != j);  // 是否不等于  true        //1.请用户输入一个整数        System.out.println(&quot;请您输入一个整数：&quot;);        Scanner sc = new Scanner(System.in);        //2.声明一个变量记录用户输入的整数        int l = sc.nextInt();        //3.声明一个布尔类型的变量判断正负        boolean d = l&lt;0;        System.out.println(&quot;d=&quot;+ d);        System.out.println(l&lt;0);    &#125;&#125;</code></pre><h4 id="四、自增减运算符"><a href="#四、自增减运算符" class="headerlink" title="四、自增减运算符"></a>四、自增减运算符</h4><ul><li><p>++a</p><pre><code>自增（前）：先运算后取值      a=2;b=++a;          a=3;b=3</code></pre></li><li><p>a++</p><pre><code>自增（后）：先取值后运算      a=2;b=a++;          a=3;b=2</code></pre></li><li><p>–a<br>自减（前）：先运算后取值</p><pre><code>a=2;b=- -a    a=1;b=1</code></pre></li><li><p>a- -<br>自减（后）：先取值后运算</p><pre><code>a=2;b=a- -    a=1;b=2</code></pre><p>自增减运算符只能用于变量，常数不可以使用</p></li><li><p>图片</p></li><li><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143847.png?raw=true"></p></li><li><p>相关代码</p><pre><code class="java">public class SelfTest &#123;public static void main(String[] args) &#123;        // 1.声明一个int类型的变量并初始化        int ia = 10;        // 2.打印变量的数值        System.out.println(&quot;ia = &quot; + ia); // ia = 10                System.out.println(&quot;---------------------------------------------&quot;);        // 3.实现自增减运算符的使用        // 表示让变量ia自身的数值加1，并覆盖该变量原来的数值           ia++;   // ia = ia + 1;        System.out.println(&quot;ia = &quot; + ia); // ia = 11                // 表示让变量ia自身的数值加1，并覆盖该变量原来的数值          ++ia;        System.out.println(&quot;ia = &quot; + ia); // ia = 12                // 表示让变量ia自身的数值减1，并覆盖该变量原来的数值        --ia;        System.out.println(&quot;ia = &quot; + ia); // ia = 11                ia--;        System.out.println(&quot;ia = &quot; + ia); // ia = 10                System.out.println(&quot;---------------------------------------------&quot;);        // 4.简单的变换        // 其中ia++这个整体叫做表达式   其中ia叫做操作数/变量       也就是ia++和ia表示不同的含义，因此所占的内存空间应该不同        // 下面的代码是在打印表达式的结果        // 后++表示先让变量ia的数值作为整个表达式的最终结果，然后再让ia变量自身的数值加1        System.out.println(ia++);         // 10        System.out.println(&quot;ia = &quot; + ia); // 11        // 前++表示先让变量自身的数值加1，然后再让变量的数值作为整个表达式的结果        System.out.println(++ia);         // 12        System.out.println(&quot;ia = &quot; + ia); // 12                System.out.println(&quot;---------------------------------------------&quot;);        // 5.笔试考点        int ib = ia++;        System.out.println(&quot;ib = &quot; + ib); // 12        System.out.println(&quot;ia = &quot; + ia); // 13        int ic = ++ia;        System.out.println(&quot;ic = &quot; + ic); // 14        System.out.println(&quot;ia = &quot; + ia); // 14                //                  14  + 16        System.out.println(ia++ + ++ia);  // 30        System.out.println(&quot;ia = &quot; + ia); // 16            &#125;&#125;</code></pre></li></ul><h4 id="五、逻辑运算符"><a href="#五、逻辑运算符" class="headerlink" title="五、逻辑运算符"></a>五、逻辑运算符</h4><p>逻辑运算符的操作数均为boolean表达式</p><h5 id="amp-amp-表示逻辑与运算符"><a href="#amp-amp-表示逻辑与运算符" class="headerlink" title="&amp;&amp; 表示逻辑与运算符"></a>&amp;&amp; 表示逻辑与运算符</h5><p>相当于”并且”，同真为真，一假为假</p><h5 id="表示逻辑或运算符"><a href="#表示逻辑或运算符" class="headerlink" title="|| 表示逻辑或运算符"></a>|| 表示逻辑或运算符</h5><p>相当于”或者”，一真为真，同假为假</p><h5 id="表示逻辑非运算符"><a href="#表示逻辑非运算符" class="headerlink" title="! 表示逻辑非运算符"></a>! 表示逻辑非运算符</h5><p>相当于”取反”，真为假，假为真</p><h5 id="amp-amp-逻辑短路"><a href="#amp-amp-逻辑短路" class="headerlink" title="&amp;&amp;   ||  逻辑短路"></a>&amp;&amp;   ||  逻辑短路</h5><p>​    • 对于逻辑与运算符来说，若第一个表达式为假则结果为假，此时跳过第二个表达式；</p><p>​    • 对于逻辑或运算符来说，若第一个表达式为真则结果为真，此时跳过第二个表达式；</p><p>​    作用： </p><p>1、由于&amp;&amp;和||的表达式存在短路运算现象，在短路之后不会对后面的表达式进行运算，所以含有&amp;&amp;和||的表达式最好不要进行变量的赋值和运算操作，可以先计算好每个表达式的结果，直接拿结果进行&amp;&amp;和||的运算<br>2、在代码编写的时候就要注意这一点，以防由于&amp;&amp;和||的短路运算导致写出来的代码运算结果与预期的不同<br>3、把能快速确定整个表达式结果true或false的表达式放在前面，这样由于短路运算后面的表达式可能不会被运算到，节省处理器的运算时间</p><p>相关代码：</p><pre><code class="java">/** * @Author: YoYopupunsi * @Description: * @Date: Created in 13:17 2021/2/3 0003 * @Modified By: */import java.util.Scanner;public class LogicalOperators &#123;    public static void main(String [] args)&#123;        // 1.声明两个boolean类型的变量并初始化        boolean b1 = true;        boolean b2 = false;        // 2.打印变量的数值        System.out.println(&quot;b1 = &quot; + b1); // b1 = true        System.out.println(&quot;b2 = &quot; + b2); // b2 = false        // 3.使用上述变量实现逻辑运算符的使用        boolean b3 = b1 &amp;&amp; b2;        System.out.println(&quot;b3 = &quot; + b3); // false        System.out.println(b1 &amp;&amp; b2); // false   并且        System.out.println(b1 || b2); // true    或者        System.out.println(!b1);  // false       取反        System.out.println(!b2);  // true        // 4.测试一下短路特性        int ia = 3;        int ib = 5;        // 对于逻辑与运算符来说，若第一个条件为假则整个表达式为假，此时跳过第二个表达式不执行        boolean b4 = (++ia == 3) &amp;&amp; (++ib == 5);        System.out.println(&quot;b4 = &quot; + b4); // false        System.out.println(&quot;ia = &quot; + ia); // 4        System.out.println(&quot;ib = &quot; + ib); // 5        // 对于逻辑或运算符来说，若第一个条件为真则整个表达式为真，此时跳过第二个表达式不执行        boolean b5 = (++ia == 5) || (++ib == 5);        System.out.println(&quot;b5 = &quot; + b5); // true        System.out.println(&quot;ia = &quot; + ia); // 5        System.out.println(&quot;ib = &quot; + ib); // 5        // 1.提示用户输入一个正整数并使用变量记录        System.out.println(&quot;请输入一个正整数：&quot;);        Scanner sc = new Scanner(System.in);        int num = sc.nextInt();        // 2.使用逻辑运算符判断是否为三位数并打印    &gt;= 100   &lt;= 999   &amp;&amp;        //System.out.println(100 &lt;= num &lt;= 999); // 错误: 二元运算符 &#39;&lt;=&#39; 的操作数类型错误        // 逻辑运算符主要用于连接多个关系运算符作为最终运算的表达式，用于实现多条件的连接        System.out.println(100 &lt;= num &amp;&amp; num &lt;= 999);        // 使用三目运算符来判断是否为三位数        System.out.println(num + ((100 &lt;= num &amp;&amp; num &lt;= 999)? &quot;是三位数&quot;: &quot;不是三位数&quot;));    &#125;&#125;</code></pre><h4 id="六、条件-三目运算符"><a href="#六、条件-三目运算符" class="headerlink" title="六、条件/三目运算符"></a>六、条件/三目运算符</h4><p>条件表达式? 表达式1: 表达式2<br>格式：a&gt;b ? a:b；<br>判断条件表达式是否成立，若成立则执行表达式1，否则执行表达式2 </p><p>相关代码：</p><pre><code class="java">import java.util.Scanner;public class TernaryOperator &#123;    public static void main(String[] args) &#123;        // 1.提示用户分別输入两个整数并使用变量记录        System.out.println(&quot;请输入第一个整数：&quot;);        Scanner sc1 = new Scanner(System.in);        int i = sc1.nextInt();        System.out.println(&quot;请输入第二个整数：&quot;);        Scanner sc2 = new Scanner(System.in);        int j = sc2.nextInt();        // 2.使用三目运算符找到最大值并打印        int maxiMum = i &gt; j ? i : j;        System.out.println(&quot;最大值是：&quot; + maxiMum);        System.out.println(&quot;最大值是：&quot; + (i &gt; j? i : j));    &#125;&#125;</code></pre><h4 id="七、赋值运算符"><a href="#七、赋值运算符" class="headerlink" title="七、赋值运算符"></a>七、赋值运算符</h4><p>符号：=<br>1.当“=”两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理<br>2.支持连续赋值<br>赋值表达式本身也有值，其本身之值即为所赋之值</p><pre><code class="java">/** * @Author: YoYopupunsi * @Description: * @Date: Created in 15:26 2021/2/3 0003 * @Modified By: */public class AssignmentOperators &#123;    public static void main(String[] args) &#123;        // 1.声明一个int类型的变量并初始化        int i = 3;        // 2.打印变量的数值        System.out.println(&quot;i = &quot; + i); // i = 3        // 3.简单赋值运算符的使用        // 表示将数据5赋值给变量ia并且覆盖变量ia原来的数值        i = 5;        // 下面的代码是在打印表达式的结果        System.out.println( i = 5 ); // 5        System.out.println(&quot;i = &quot; + i); // i = 5        int j = i = 6;        System.out.println(&quot;i = &quot; + i); // i = 6        System.out.println(&quot;j = &quot; + j); // j = 6        int k;        k = j = i = 8;        System.out.println(&quot;i = &quot; + i); // i = 8        System.out.println(&quot;j = &quot; + j); // j = 8        System.out.println(&quot;k = &quot; + k); // k = 8        // 4.复合赋值运算符的使用        //i = i + 2;  目前推荐使用该方式        i += 2;        // 简化写法，从结果上来看是等价的        System.out.println(&quot;i = &quot; + i); // i = 10        // 5.笔试考点1        byte l = 10;        System.out.println(&quot;l = &quot; + l); // l = 10        //l = l + 2; // 错误: 不兼容的类型: 从int转换到byte可能会有损失         byte + int 相加结果还是int类型        //l = l + (byte)2; // 错误: 不兼容的类型: 从int转换到byte可能会有损失   byte + byte 相加结果还是int类型  编译器优化        //l = (byte)(l + 2); // 强制类型转换，将int类型转换为byte        l += 2; // 真正等价于l = (byte)(l + 2);        System.out.println(&quot;l = &quot; + l); // l = 12        l -= 2;        System.out.println(&quot;l-=2= &quot; + l);//l=10        l *= 2;        System.out.println(&quot;l*=2= &quot; + l);//20        l /= 2;        System.out.println(&quot;l/=2= &quot; + l);//10        l %= 2;        System.out.println(&quot;l%=2= &quot; + l);//0        // 6.笔试考点2        int a = 1;        boolean b = a == 1; //a==1; 表示判断变量b的数值是否等于1        System.out.println(b);//ture        System.out.println(a == 1);//ture        boolean b1 = 1 == a;//1 == a; 表示判断1是否等于变量a的数值，从结果上来说等价，推荐该方式        System.out.println(b1);//ture        System.out.println(1 == a);//ture        System.out.println(a = 1);//a = 1;   表示将1赋值给变量a，覆盖变量a原来的数值       //System.out.println(1 = a);//1 = a;  //- 编译报错  错误: 意外的类型  需要: 变量  找到:    值    &#125;&#125;</code></pre><h4 id="八、移位运算符"><a href="#八、移位运算符" class="headerlink" title="八、移位运算符"></a>八、移位运算符</h4><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143222.jpg?raw=true" alt="移位运算符"></p><pre><code class="java">public class MoveBitTest &#123;        public static void main(String[] args) &#123;                // 1.声明一个byte类型的变量并初始化        byte b1 = 13;        // 2.打印变量的数值        System.out.println(&quot;b1 = &quot; + b1); // b1 = 13                System.out.println(&quot;---------------------------------------------------&quot;);        // 3.移位运算符的使用        // 13的二进制是：... 0000 1101  =&gt; 左移1位的结果是：... 0001 1010 =&gt; 换算为十进制整数是：26        //byte b2 = b1 &lt;&lt; 1; // 错误: 不兼容的类型: 从int转换到byte可能会有损失   自动提升为int类型，也就是32位二进制        byte b2 = (byte)(b1 &lt;&lt; 1);         System.out.println(&quot;b2 = &quot; + b2); // 26        System.out.println(b1 &lt;&lt; 1); // 26    左移1位相当于当前整数的数值*2        System.out.println(b1 &lt;&lt; 2); // 52    左移2位相当于当前整数的数值*4                System.out.println(&quot;---------------------------------------------------&quot;);        // 13的二进制是：... 0000 1101 =&gt; 右移1位的结果是：... 0000 0110 =&gt; 换算为十进制整数是：6        System.out.println(b1 &gt;&gt; 1); // 6     右移1位相当于当前整数的数值/2        System.out.println(b1 &gt;&gt; 2); // 3     右移2位相当于当前整数的数值/4                System.out.println(&quot;---------------------------------------------------&quot;);        // 逻辑右移   对于非负数来说，逻辑右移和右移的效果一致        System.out.println(b1 &gt;&gt;&gt; 2); // 3      &#125;&#125;</code></pre><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143848.png?raw=true"></p><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143849.png?raw=true"></p><h4 id="九、位运算符"><a href="#九、位运算符" class="headerlink" title="九、位运算符"></a>九、位运算符</h4><ul><li>&amp; 表示按位与运算符，按照二进制位进行与运算，同1为1，一0为0.</li><li>| 表示按位或运算符，按照二进制位进行或运算，一1为1，同0为0.</li><li>~ 表示按位取反运算符，按照二进制位进行取反，1为0，0为1.</li><li>^ 表示按位异或运算符，按照二进制位进行异或运算，同为0，不同为1.</li><li>相关代码：</li></ul><pre><code class="java">public class BitTest &#123;        public static void main(String[] args) &#123;                // 1.声明两个byte类型的变量并初始化        byte b1 = 11;        byte b2 = 13;        // 2.打印变量的数值        System.out.println(&quot;b1 = &quot; + b1); // b1 = 11        System.out.println(&quot;b2 = &quot; + b2); // b2 = 13                System.out.println(&quot;---------------------------------------------------&quot;);        // 3.实现位运算符的使用        // b1的二进制为： 0000 1011                  // b2的二进制为： 0000 1101        System.out.println( b1 &amp; b2);  // 按位与：同1为1，一0为0      按位与后的二进制为：0000 1001  =&gt; 转为十进制是：9        System.out.println( b1 | b2);  // 按位或：一1为1，同0为0      按位或后的二进制为：0000 1111  =&gt; 转为十进制是：15        System.out.println( b1 ^ b2);  // 按位异或：相同为0，不同为1  按位异或的二进制为：0000 0110  =&gt; 转为十进制是：6        System.out.println( ~ b1);     // 按位取反：1为0,0为1         按位取反的二进制为：1111 0100         // 二进制1111 0100转为十进制 =&gt; 先减1: 1111 0011 =&gt; 按位取反：0000 1100 =&gt; 转为十进制：12  =&gt; 添加负号：-12    &#125;&#125;</code></pre><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143845.png?raw=true"></p><h4 id="十、运算符的优先级"><a href="#十、运算符的优先级" class="headerlink" title="十、运算符的优先级"></a>十、运算符的优先级</h4><ul><li>()的优先级极高 </li><li>=的优先级极低</li><li>若无法确认优先级，则使用()来确保即可</li></ul><p><img src="https://github.com/YoYopupunsi/PicGoImgbed/blob/main/posts/20210213143846.png?raw=true"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机语言的概述 </tag>
            
            <tag> 变量及数据类型 </tag>
            
            <tag> 运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客搭建</title>
      <link href="posts/e3e08109.html"/>
      <url>posts/e3e08109.html</url>
      
        <content type="html"><![CDATA[<p>你无法把点滴与未来联系</p><p>You can‘t connect the dots looking forward.</p><p>You can only connect them,looking backwars.</p><p>所以你必须相信过去的点滴能串联未来</p><p>So you have to trust that the dots will somehow connect in your future.</p><p>你必须有信念</p><p>You have to trust in something</p><p>不管那是你的胆识、命运、人生、还是因果报应</p><p>因为把过去点滴串联起来</p><p>Because believing that the dots will connect down the road</p><p>才能有信念忠于自我</p><p>Will give you the confidence to follow your heart</p><p>即使你的选择和别的不一样</p><p>Even it’ll lead you off the well worn path</p><p>这会使你与众不同</p><p>And that will make all the difference</p><p>你的时间是有限的</p><p>Your time is limited</p><p>不要浪费在其他人的生命当中</p><p>So don’t waste it living someone else’s life</p><p>别受教条约束</p><p>Don’t trapped by the dogma</p><p>别活在其他人对你的期望之中</p><p>which is living with results of other people’s thinking</p><p>别让批评抹去了你内心的声音</p><p>你得找到你所爱的东西</p><p>You‘ve got to find what you love</p><p>包括你热爱的事业和你的伴侣</p><p>And that is as the true for work as it for your lover</p><p>你的工作将会占据你生命的大部分</p><p>Your work is going to fill a large part of your life</p><p>相信你做的工作是对的，你才能发自内心得到满足</p><p>and the only way to be truly satisfied is to do what you believe is great work.</p><p>而只有爱你所做的事，才能成就不凡</p><p>And the only to do the great work is to love what you do.</p><p>如果你还没有找到</p><p>If you haven’t found it yet</p><p>那继续找</p><p>keep looking,and don’t settle</p>]]></content>
      
      
      <categories>
          
          <category> 博客篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
